/* tslint:disable */
/* eslint-disable */
/**
 * Purplship API
 *  ## API Reference  Purplship is an open source multi-carrier shipping API that simplifies the integration of logistic carrier services.  The Purplship API is organized around REST. Our API has predictable resource-oriented URLs, accepts JSON-encoded  request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.  The Purplship API differs for every account as we release new versions. These docs are customized to your version of the API.   ## Versioning  When backwards-incompatible changes are made to the API, a new, dated version is released.  The current version is `2021.7`.   Read our API changelog and to learn more about backwards compatibility.  As a precaution, use API versioning to check a new API version before committing to an upgrade.   ## Pagination  All top-level API resources have support for bulk fetches via \"list\" API methods. For instance, you can list addresses,  list shipments, and list trackers. These list API methods share a common structure, taking at least these  two parameters: limit, and offset.  Purplship utilizes offset-based pagination via the offset and limit parameters. Both parameters take a number as value (see below) and return objects in reverse chronological order.  The offset parameter returns objects listed after an index.  The limit parameter take a limit on the number of objects to be returned from 1 to 100.   ```json {     \"next\": \"/v1/shipments?limit=25&offset=25\",     \"previous\": \"/v1/shipments?limit=25&offset=25\",     \"results\": [     ] } ```  ## Environments  The Purplship API offer the possibility to create and retrieve certain objects in `test_mode`. In development, it is therefore possible to add carrier connections, get live rates,  buy labels, create trackers and schedule pickups in `test_mode`.  
 *
 * The version of the OpenAPI document: 2021.7
 * Contact: hello@purplship.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    access: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Address
     */
    id?: string;
    /**
     *  The address postal code  **(required for shipment purchase)** 
     * @type {string}
     * @memberof Address
     */
    postal_code?: string | null;
    /**
     *  The address city.  **(required for shipment purchase)** 
     * @type {string}
     * @memberof Address
     */
    city?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof Address
     */
    federal_tax_id?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof Address
     */
    state_tax_id?: string | null;
    /**
     *  attention to  **(required for shipment purchase)** 
     * @type {string}
     * @memberof Address
     */
    person_name?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof Address
     */
    company_name?: string | null;
    /**
     * The address country code
     * @type {string}
     * @memberof Address
     */
    country_code: AddressCountryCodeEnum;
    /**
     * The party email
     * @type {string}
     * @memberof Address
     */
    email?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof Address
     */
    phone_number?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof Address
     */
    state_code?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof Address
     */
    suburb?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof Address
     */
    residential?: boolean | null;
    /**
     *  The address line with street number <br/> **(required for shipment purchase)** 
     * @type {string}
     * @memberof Address
     */
    address_line1?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof Address
     */
    address_line2?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof Address
     */
    validate_location?: boolean | null;
    /**
     * 
     * @type {AddressValidation}
     * @memberof Address
     */
    validation?: AddressValidation | null;
}

/**
    * @export
    * @enum {string}
    */
export enum AddressCountryCodeEnum {
    ad = 'AD',
    ae = 'AE',
    af = 'AF',
    ag = 'AG',
    ai = 'AI',
    al = 'AL',
    am = 'AM',
    an = 'AN',
    ao = 'AO',
    ar = 'AR',
    as = 'AS',
    at = 'AT',
    au = 'AU',
    aw = 'AW',
    az = 'AZ',
    ba = 'BA',
    bb = 'BB',
    bd = 'BD',
    be = 'BE',
    bf = 'BF',
    bg = 'BG',
    bh = 'BH',
    bi = 'BI',
    bj = 'BJ',
    bm = 'BM',
    bn = 'BN',
    bo = 'BO',
    br = 'BR',
    bs = 'BS',
    bt = 'BT',
    bw = 'BW',
    by = 'BY',
    bz = 'BZ',
    ca = 'CA',
    cd = 'CD',
    cf = 'CF',
    cg = 'CG',
    ch = 'CH',
    ci = 'CI',
    ck = 'CK',
    cl = 'CL',
    cm = 'CM',
    cn = 'CN',
    co = 'CO',
    cr = 'CR',
    cu = 'CU',
    cv = 'CV',
    cy = 'CY',
    cz = 'CZ',
    de = 'DE',
    dj = 'DJ',
    dk = 'DK',
    dm = 'DM',
    do = 'DO',
    dz = 'DZ',
    ec = 'EC',
    ee = 'EE',
    eg = 'EG',
    er = 'ER',
    es = 'ES',
    et = 'ET',
    fi = 'FI',
    fj = 'FJ',
    fk = 'FK',
    fm = 'FM',
    fo = 'FO',
    fr = 'FR',
    ga = 'GA',
    gb = 'GB',
    gd = 'GD',
    ge = 'GE',
    gf = 'GF',
    gg = 'GG',
    gh = 'GH',
    gi = 'GI',
    gl = 'GL',
    gm = 'GM',
    gn = 'GN',
    gp = 'GP',
    gq = 'GQ',
    gr = 'GR',
    gt = 'GT',
    gu = 'GU',
    gw = 'GW',
    gy = 'GY',
    hk = 'HK',
    hn = 'HN',
    hr = 'HR',
    ht = 'HT',
    hu = 'HU',
    ic = 'IC',
    id = 'ID',
    ie = 'IE',
    il = 'IL',
    in = 'IN',
    iq = 'IQ',
    ir = 'IR',
    is = 'IS',
    it = 'IT',
    je = 'JE',
    jm = 'JM',
    jo = 'JO',
    jp = 'JP',
    ke = 'KE',
    kg = 'KG',
    kh = 'KH',
    ki = 'KI',
    km = 'KM',
    kn = 'KN',
    kp = 'KP',
    kr = 'KR',
    kv = 'KV',
    kw = 'KW',
    ky = 'KY',
    kz = 'KZ',
    la = 'LA',
    lb = 'LB',
    lc = 'LC',
    li = 'LI',
    lk = 'LK',
    lr = 'LR',
    ls = 'LS',
    lt = 'LT',
    lu = 'LU',
    lv = 'LV',
    ly = 'LY',
    ma = 'MA',
    mc = 'MC',
    md = 'MD',
    me = 'ME',
    mg = 'MG',
    mh = 'MH',
    mk = 'MK',
    ml = 'ML',
    mm = 'MM',
    mn = 'MN',
    mo = 'MO',
    mp = 'MP',
    mq = 'MQ',
    mr = 'MR',
    ms = 'MS',
    mt = 'MT',
    mu = 'MU',
    mv = 'MV',
    mw = 'MW',
    mx = 'MX',
    my = 'MY',
    mz = 'MZ',
    na = 'NA',
    nc = 'NC',
    ne = 'NE',
    ng = 'NG',
    ni = 'NI',
    nl = 'NL',
    no = 'NO',
    np = 'NP',
    nr = 'NR',
    nu = 'NU',
    nz = 'NZ',
    om = 'OM',
    pa = 'PA',
    pe = 'PE',
    pf = 'PF',
    pg = 'PG',
    ph = 'PH',
    pk = 'PK',
    pl = 'PL',
    pr = 'PR',
    pt = 'PT',
    pw = 'PW',
    py = 'PY',
    qa = 'QA',
    re = 'RE',
    ro = 'RO',
    rs = 'RS',
    ru = 'RU',
    rw = 'RW',
    sa = 'SA',
    sb = 'SB',
    sc = 'SC',
    sd = 'SD',
    se = 'SE',
    sg = 'SG',
    sh = 'SH',
    si = 'SI',
    sk = 'SK',
    sl = 'SL',
    sm = 'SM',
    sn = 'SN',
    so = 'SO',
    sr = 'SR',
    ss = 'SS',
    st = 'ST',
    sv = 'SV',
    sy = 'SY',
    sz = 'SZ',
    tc = 'TC',
    td = 'TD',
    tg = 'TG',
    th = 'TH',
    tj = 'TJ',
    tl = 'TL',
    tn = 'TN',
    to = 'TO',
    tr = 'TR',
    tt = 'TT',
    tv = 'TV',
    tw = 'TW',
    tz = 'TZ',
    ua = 'UA',
    ug = 'UG',
    us = 'US',
    uy = 'UY',
    uz = 'UZ',
    va = 'VA',
    vc = 'VC',
    ve = 'VE',
    vg = 'VG',
    vi = 'VI',
    vn = 'VN',
    vu = 'VU',
    ws = 'WS',
    xb = 'XB',
    xc = 'XC',
    xe = 'XE',
    xm = 'XM',
    xn = 'XN',
    xs = 'XS',
    xy = 'XY',
    ye = 'YE',
    yt = 'YT',
    za = 'ZA',
    zm = 'ZM',
    zw = 'ZW'
}

/**
 * 
 * @export
 * @interface AddressData
 */
export interface AddressData {
    /**
     *  The address postal code  **(required for shipment purchase)** 
     * @type {string}
     * @memberof AddressData
     */
    postal_code?: string | null;
    /**
     *  The address city.  **(required for shipment purchase)** 
     * @type {string}
     * @memberof AddressData
     */
    city?: string | null;
    /**
     * The party frederal tax id
     * @type {string}
     * @memberof AddressData
     */
    federal_tax_id?: string | null;
    /**
     * The party state id
     * @type {string}
     * @memberof AddressData
     */
    state_tax_id?: string | null;
    /**
     *  attention to  **(required for shipment purchase)** 
     * @type {string}
     * @memberof AddressData
     */
    person_name?: string | null;
    /**
     * The company name if the party is a company
     * @type {string}
     * @memberof AddressData
     */
    company_name?: string | null;
    /**
     * The address country code
     * @type {string}
     * @memberof AddressData
     */
    country_code: AddressDataCountryCodeEnum;
    /**
     * The party email
     * @type {string}
     * @memberof AddressData
     */
    email?: string | null;
    /**
     * The party phone number.
     * @type {string}
     * @memberof AddressData
     */
    phone_number?: string | null;
    /**
     * The address state code
     * @type {string}
     * @memberof AddressData
     */
    state_code?: string | null;
    /**
     * The address suburb if known
     * @type {string}
     * @memberof AddressData
     */
    suburb?: string | null;
    /**
     * Indicate if the address is residential or commercial (enterprise)
     * @type {boolean}
     * @memberof AddressData
     */
    residential?: boolean | null;
    /**
     *  The address line with street number <br/> **(required for shipment purchase)** 
     * @type {string}
     * @memberof AddressData
     */
    address_line1?: string | null;
    /**
     * The address line with suite number
     * @type {string}
     * @memberof AddressData
     */
    address_line2?: string | null;
    /**
     * Indicate if the address should be validated
     * @type {boolean}
     * @memberof AddressData
     */
    validate_location?: boolean | null;
}

/**
    * @export
    * @enum {string}
    */
export enum AddressDataCountryCodeEnum {
    ad = 'AD',
    ae = 'AE',
    af = 'AF',
    ag = 'AG',
    ai = 'AI',
    al = 'AL',
    am = 'AM',
    an = 'AN',
    ao = 'AO',
    ar = 'AR',
    as = 'AS',
    at = 'AT',
    au = 'AU',
    aw = 'AW',
    az = 'AZ',
    ba = 'BA',
    bb = 'BB',
    bd = 'BD',
    be = 'BE',
    bf = 'BF',
    bg = 'BG',
    bh = 'BH',
    bi = 'BI',
    bj = 'BJ',
    bm = 'BM',
    bn = 'BN',
    bo = 'BO',
    br = 'BR',
    bs = 'BS',
    bt = 'BT',
    bw = 'BW',
    by = 'BY',
    bz = 'BZ',
    ca = 'CA',
    cd = 'CD',
    cf = 'CF',
    cg = 'CG',
    ch = 'CH',
    ci = 'CI',
    ck = 'CK',
    cl = 'CL',
    cm = 'CM',
    cn = 'CN',
    co = 'CO',
    cr = 'CR',
    cu = 'CU',
    cv = 'CV',
    cy = 'CY',
    cz = 'CZ',
    de = 'DE',
    dj = 'DJ',
    dk = 'DK',
    dm = 'DM',
    do = 'DO',
    dz = 'DZ',
    ec = 'EC',
    ee = 'EE',
    eg = 'EG',
    er = 'ER',
    es = 'ES',
    et = 'ET',
    fi = 'FI',
    fj = 'FJ',
    fk = 'FK',
    fm = 'FM',
    fo = 'FO',
    fr = 'FR',
    ga = 'GA',
    gb = 'GB',
    gd = 'GD',
    ge = 'GE',
    gf = 'GF',
    gg = 'GG',
    gh = 'GH',
    gi = 'GI',
    gl = 'GL',
    gm = 'GM',
    gn = 'GN',
    gp = 'GP',
    gq = 'GQ',
    gr = 'GR',
    gt = 'GT',
    gu = 'GU',
    gw = 'GW',
    gy = 'GY',
    hk = 'HK',
    hn = 'HN',
    hr = 'HR',
    ht = 'HT',
    hu = 'HU',
    ic = 'IC',
    id = 'ID',
    ie = 'IE',
    il = 'IL',
    in = 'IN',
    iq = 'IQ',
    ir = 'IR',
    is = 'IS',
    it = 'IT',
    je = 'JE',
    jm = 'JM',
    jo = 'JO',
    jp = 'JP',
    ke = 'KE',
    kg = 'KG',
    kh = 'KH',
    ki = 'KI',
    km = 'KM',
    kn = 'KN',
    kp = 'KP',
    kr = 'KR',
    kv = 'KV',
    kw = 'KW',
    ky = 'KY',
    kz = 'KZ',
    la = 'LA',
    lb = 'LB',
    lc = 'LC',
    li = 'LI',
    lk = 'LK',
    lr = 'LR',
    ls = 'LS',
    lt = 'LT',
    lu = 'LU',
    lv = 'LV',
    ly = 'LY',
    ma = 'MA',
    mc = 'MC',
    md = 'MD',
    me = 'ME',
    mg = 'MG',
    mh = 'MH',
    mk = 'MK',
    ml = 'ML',
    mm = 'MM',
    mn = 'MN',
    mo = 'MO',
    mp = 'MP',
    mq = 'MQ',
    mr = 'MR',
    ms = 'MS',
    mt = 'MT',
    mu = 'MU',
    mv = 'MV',
    mw = 'MW',
    mx = 'MX',
    my = 'MY',
    mz = 'MZ',
    na = 'NA',
    nc = 'NC',
    ne = 'NE',
    ng = 'NG',
    ni = 'NI',
    nl = 'NL',
    no = 'NO',
    np = 'NP',
    nr = 'NR',
    nu = 'NU',
    nz = 'NZ',
    om = 'OM',
    pa = 'PA',
    pe = 'PE',
    pf = 'PF',
    pg = 'PG',
    ph = 'PH',
    pk = 'PK',
    pl = 'PL',
    pr = 'PR',
    pt = 'PT',
    pw = 'PW',
    py = 'PY',
    qa = 'QA',
    re = 'RE',
    ro = 'RO',
    rs = 'RS',
    ru = 'RU',
    rw = 'RW',
    sa = 'SA',
    sb = 'SB',
    sc = 'SC',
    sd = 'SD',
    se = 'SE',
    sg = 'SG',
    sh = 'SH',
    si = 'SI',
    sk = 'SK',
    sl = 'SL',
    sm = 'SM',
    sn = 'SN',
    so = 'SO',
    sr = 'SR',
    ss = 'SS',
    st = 'ST',
    sv = 'SV',
    sy = 'SY',
    sz = 'SZ',
    tc = 'TC',
    td = 'TD',
    tg = 'TG',
    th = 'TH',
    tj = 'TJ',
    tl = 'TL',
    tn = 'TN',
    to = 'TO',
    tr = 'TR',
    tt = 'TT',
    tv = 'TV',
    tw = 'TW',
    tz = 'TZ',
    ua = 'UA',
    ug = 'UG',
    us = 'US',
    uy = 'UY',
    uz = 'UZ',
    va = 'VA',
    vc = 'VC',
    ve = 'VE',
    vg = 'VG',
    vi = 'VI',
    vn = 'VN',
    vu = 'VU',
    ws = 'WS',
    xb = 'XB',
    xc = 'XC',
    xe = 'XE',
    xm = 'XM',
    xn = 'XN',
    xs = 'XS',
    xy = 'XY',
    ye = 'YE',
    yt = 'YT',
    za = 'ZA',
    zm = 'ZM',
    zw = 'ZW'
}

/**
 * 
 * @export
 * @interface AddressList
 */
export interface AddressList {
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressList
     */
    previous?: string;
    /**
     * 
     * @type {Array<Address>}
     * @memberof AddressList
     */
    results: Array<Address>;
}
/**
 * Specify address validation result
 * @export
 * @interface AddressValidation
 */
export interface AddressValidation {
    /**
     * True if the address is valid
     * @type {boolean}
     * @memberof AddressValidation
     */
    success: boolean;
    /**
     * validation service details
     * @type {object}
     * @memberof AddressValidation
     */
    meta?: object | null;
}
/**
 * 
 * @export
 * @interface CarrierList
 */
export interface CarrierList {
    /**
     * 
     * @type {string}
     * @memberof CarrierList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof CarrierList
     */
    previous?: string;
    /**
     * 
     * @type {Array<CarrierSettings>}
     * @memberof CarrierList
     */
    results: Array<CarrierSettings>;
}
/**
 * 
 * @export
 * @interface CarrierSettings
 */
export interface CarrierSettings {
    /**
     * A unique address identifier
     * @type {string}
     * @memberof CarrierSettings
     */
    id: string;
    /**
     * Indicates a carrier (type)
     * @type {string}
     * @memberof CarrierSettings
     */
    carrier_name: CarrierSettingsCarrierNameEnum;
    /**
     * Indicates a specific carrier configuration name.
     * @type {string}
     * @memberof CarrierSettings
     */
    carrier_id: string;
    /**
     *  The test flag indicates whether to use a carrier configured for test.  
     * @type {boolean}
     * @memberof CarrierSettings
     */
    test: boolean;
    /**
     *  The active flag indicates whether the carrier account is active or not.  
     * @type {boolean}
     * @memberof CarrierSettings
     */
    active: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum CarrierSettingsCarrierNameEnum {
    aramex = 'aramex',
    australiapost = 'australiapost',
    canadapost = 'canadapost',
    canpar = 'canpar',
    dhl_express = 'dhl_express',
    dhl_universal = 'dhl_universal',
    dicom = 'dicom',
    eshipper = 'eshipper',
    fedex = 'fedex',
    freightcom = 'freightcom',
    purolator = 'purolator',
    royalmail = 'royalmail',
    sendle = 'sendle',
    sf_express = 'sf_express',
    tnt = 'tnt',
    ups = 'ups',
    usps = 'usps',
    usps_international = 'usps_international',
    yanwen = 'yanwen',
    yunexpress = 'yunexpress'
}

/**
 * The pickup cost details
 * @export
 * @interface Charge
 */
export interface Charge {
    /**
     * The charge description
     * @type {string}
     * @memberof Charge
     */
    name?: string | null;
    /**
     * The charge monetary value
     * @type {number}
     * @memberof Charge
     */
    amount?: number | null;
    /**
     * The charge amount currency
     * @type {string}
     * @memberof Charge
     */
    currency?: string | null;
}
/**
 * The parcel content items
 * @export
 * @interface Commodity
 */
export interface Commodity {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Commodity
     */
    id?: string;
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof Commodity
     */
    weight: number;
    /**
     * The commodity\'s weight unit
     * @type {string}
     * @memberof Commodity
     */
    weight_unit: CommodityWeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof Commodity
     */
    description?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof Commodity
     */
    quantity?: number | null;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof Commodity
     */
    sku?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof Commodity
     */
    value_amount?: number | null;
    /**
     * The currency of the commodity value amount
     * @type {string}
     * @memberof Commodity
     */
    value_currency?: string | null;
    /**
     * The origin or manufacture country
     * @type {string}
     * @memberof Commodity
     */
    origin_country?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum CommodityWeightUnitEnum {
    kg = 'KG',
    lb = 'LB'
}

/**
 * 
 * @export
 * @interface CommodityData
 */
export interface CommodityData {
    /**
     * The commodity\'s weight
     * @type {number}
     * @memberof CommodityData
     */
    weight: number;
    /**
     * The commodity\'s weight unit
     * @type {string}
     * @memberof CommodityData
     */
    weight_unit: CommodityDataWeightUnitEnum;
    /**
     * A description of the commodity
     * @type {string}
     * @memberof CommodityData
     */
    description?: string | null;
    /**
     * The commodity\'s quantity (number or item)
     * @type {number}
     * @memberof CommodityData
     */
    quantity?: number | null;
    /**
     * The commodity\'s sku number
     * @type {string}
     * @memberof CommodityData
     */
    sku?: string | null;
    /**
     * The monetary value of the commodity
     * @type {number}
     * @memberof CommodityData
     */
    value_amount?: number | null;
    /**
     * The currency of the commodity value amount
     * @type {string}
     * @memberof CommodityData
     */
    value_currency?: string | null;
    /**
     * The origin or manufacture country
     * @type {string}
     * @memberof CommodityData
     */
    origin_country?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum CommodityDataWeightUnitEnum {
    kg = 'KG',
    lb = 'LB'
}

/**
 * 
 * @export
 * @interface Customs
 */
export interface Customs {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Customs
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    aes?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    eel_pfc?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    content_type?: CustomsContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    content_description?: string | null;
    /**
     * The customs \'term of trade\' also known as \'incoterm\'
     * @type {string}
     * @memberof Customs
     */
    incoterm?: CustomsIncotermEnum;
    /**
     * The parcel content items
     * @type {Array<Commodity>}
     * @memberof Customs
     */
    commodities?: Array<Commodity> | null;
    /**
     * 
     * @type {Duty}
     * @memberof Customs
     */
    duty?: Duty | null;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof Customs
     */
    invoice?: string | null;
    /**
     * The invoice date
     * @type {string}
     * @memberof Customs
     */
    invoice_date?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof Customs
     */
    commercial_invoice?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof Customs
     */
    certify?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    signer?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customs
     */
    certificate_number?: string | null;
    /**
     * 
     * @type {object}
     * @memberof Customs
     */
    options?: object | null;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomsContentTypeEnum {
    documents = 'documents',
    gift = 'gift',
    sample = 'sample',
    merchandise = 'merchandise',
    return_merchandise = 'return_merchandise',
    other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum CustomsIncotermEnum {
    cfr = 'CFR',
    cif = 'CIF',
    cip = 'CIP',
    cpt = 'CPT',
    daf = 'DAF',
    ddp = 'DDP',
    ddu = 'DDU',
    deq = 'DEQ',
    des = 'DES',
    exw = 'EXW',
    fas = 'FAS',
    fca = 'FCA',
    fob = 'FOB'
}

/**
 * 
 * @export
 * @interface CustomsData
 */
export interface CustomsData {
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    aes?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    eel_pfc?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    content_type?: CustomsDataContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    content_description?: string | null;
    /**
     * The customs \'term of trade\' also known as \'incoterm\'
     * @type {string}
     * @memberof CustomsData
     */
    incoterm?: CustomsDataIncotermEnum;
    /**
     * The parcel content items
     * @type {Array<Commodity>}
     * @memberof CustomsData
     */
    commodities?: Array<Commodity> | null;
    /**
     * 
     * @type {Duty}
     * @memberof CustomsData
     */
    duty?: Duty | null;
    /**
     * The invoice reference number
     * @type {string}
     * @memberof CustomsData
     */
    invoice?: string | null;
    /**
     * The invoice date
     * @type {string}
     * @memberof CustomsData
     */
    invoice_date?: string | null;
    /**
     * Indicates if the shipment is commercial
     * @type {boolean}
     * @memberof CustomsData
     */
    commercial_invoice?: boolean | null;
    /**
     * Indicate that signer certified confirmed all
     * @type {boolean}
     * @memberof CustomsData
     */
    certify?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    signer?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CustomsData
     */
    certificate_number?: string | null;
    /**
     * 
     * @type {object}
     * @memberof CustomsData
     */
    options?: object | null;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomsDataContentTypeEnum {
    documents = 'documents',
    gift = 'gift',
    sample = 'sample',
    merchandise = 'merchandise',
    return_merchandise = 'return_merchandise',
    other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum CustomsDataIncotermEnum {
    cfr = 'CFR',
    cif = 'CIF',
    cip = 'CIP',
    cpt = 'CPT',
    daf = 'DAF',
    ddp = 'DDP',
    ddu = 'DDU',
    deq = 'DEQ',
    des = 'DES',
    exw = 'EXW',
    fas = 'FAS',
    fca = 'FCA',
    fob = 'FOB'
}

/**
 * 
 * @export
 * @interface CustomsList
 */
export interface CustomsList {
    /**
     * 
     * @type {string}
     * @memberof CustomsList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomsList
     */
    previous?: string;
    /**
     * 
     * @type {Array<Customs>}
     * @memberof CustomsList
     */
    results: Array<Customs>;
}
/**
 *  The payment details.<br/> Note that this is required for a Dutiable parcel shipped internationally. 
 * @export
 * @interface Duty
 */
export interface Duty {
    /**
     * The duty payer
     * @type {string}
     * @memberof Duty
     */
    paid_by?: DutyPaidByEnum;
    /**
     * The declared value currency
     * @type {string}
     * @memberof Duty
     */
    currency?: DutyCurrencyEnum;
    /**
     * The package declared value
     * @type {number}
     * @memberof Duty
     */
    declared_value?: number | null;
    /**
     * The duty payment account number
     * @type {string}
     * @memberof Duty
     */
    account_number?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Duty
     */
    bill_to?: Address;
}

/**
    * @export
    * @enum {string}
    */
export enum DutyPaidByEnum {
    sender = 'sender',
    recipient = 'recipient',
    third_party = 'third_party'
}
/**
    * @export
    * @enum {string}
    */
export enum DutyCurrencyEnum {
    eur = 'EUR',
    aed = 'AED',
    usd = 'USD',
    xcd = 'XCD',
    amd = 'AMD',
    ang = 'ANG',
    aoa = 'AOA',
    ars = 'ARS',
    aud = 'AUD',
    awg = 'AWG',
    azn = 'AZN',
    bam = 'BAM',
    bbd = 'BBD',
    bdt = 'BDT',
    xof = 'XOF',
    bgn = 'BGN',
    bhd = 'BHD',
    bif = 'BIF',
    bmd = 'BMD',
    bnd = 'BND',
    bob = 'BOB',
    brl = 'BRL',
    bsd = 'BSD',
    btn = 'BTN',
    bwp = 'BWP',
    byn = 'BYN',
    bzd = 'BZD',
    cad = 'CAD',
    cdf = 'CDF',
    xaf = 'XAF',
    chf = 'CHF',
    nzd = 'NZD',
    clp = 'CLP',
    cny = 'CNY',
    cop = 'COP',
    crc = 'CRC',
    cuc = 'CUC',
    cve = 'CVE',
    czk = 'CZK',
    djf = 'DJF',
    dkk = 'DKK',
    dop = 'DOP',
    dzd = 'DZD',
    egp = 'EGP',
    ern = 'ERN',
    etb = 'ETB',
    fjd = 'FJD',
    gbp = 'GBP',
    gel = 'GEL',
    ghs = 'GHS',
    gmd = 'GMD',
    gnf = 'GNF',
    gtq = 'GTQ',
    gyd = 'GYD',
    hkd = 'HKD',
    hnl = 'HNL',
    hrk = 'HRK',
    htg = 'HTG',
    huf = 'HUF',
    idr = 'IDR',
    ils = 'ILS',
    inr = 'INR',
    irr = 'IRR',
    isk = 'ISK',
    jmd = 'JMD',
    jod = 'JOD',
    jpy = 'JPY',
    kes = 'KES',
    kgs = 'KGS',
    khr = 'KHR',
    kmf = 'KMF',
    kpw = 'KPW',
    krw = 'KRW',
    kwd = 'KWD',
    kyd = 'KYD',
    kzt = 'KZT',
    lak = 'LAK',
    lkr = 'LKR',
    lrd = 'LRD',
    lsl = 'LSL',
    lyd = 'LYD',
    mad = 'MAD',
    mdl = 'MDL',
    mga = 'MGA',
    mkd = 'MKD',
    mmk = 'MMK',
    mnt = 'MNT',
    mop = 'MOP',
    mro = 'MRO',
    mur = 'MUR',
    mvr = 'MVR',
    mwk = 'MWK',
    mxn = 'MXN',
    myr = 'MYR',
    mzn = 'MZN',
    nad = 'NAD',
    xpf = 'XPF',
    ngn = 'NGN',
    nio = 'NIO',
    nok = 'NOK',
    npr = 'NPR',
    omr = 'OMR',
    pen = 'PEN',
    pgk = 'PGK',
    php = 'PHP',
    pkr = 'PKR',
    pln = 'PLN',
    pyg = 'PYG',
    qar = 'QAR',
    rsd = 'RSD',
    rub = 'RUB',
    rwf = 'RWF',
    sar = 'SAR',
    sbd = 'SBD',
    scr = 'SCR',
    sdg = 'SDG',
    sek = 'SEK',
    sgd = 'SGD',
    shp = 'SHP',
    sll = 'SLL',
    sos = 'SOS',
    srd = 'SRD',
    ssp = 'SSP',
    std = 'STD',
    syp = 'SYP',
    szl = 'SZL',
    thb = 'THB',
    tjs = 'TJS',
    tnd = 'TND',
    top = 'TOP',
    try = 'TRY',
    ttd = 'TTD',
    twd = 'TWD',
    tzs = 'TZS',
    uah = 'UAH',
    uyu = 'UYU',
    uzs = 'UZS',
    vef = 'VEF',
    vnd = 'VND',
    vuv = 'VUV',
    wst = 'WST',
    yer = 'YER',
    zar = 'ZAR'
}

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * The list of error messages
     * @type {Array<Message>}
     * @memberof ErrorResponse
     */
    messages?: Array<Message>;
}
/**
 * The list of error messages
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * The targeted carrier
     * @type {string}
     * @memberof Message
     */
    carrier_name?: string;
    /**
     * The targeted carrier name (unique identifier)
     * @type {string}
     * @memberof Message
     */
    carrier_id?: string;
    /**
     * The error or warning message
     * @type {string}
     * @memberof Message
     */
    message?: string;
    /**
     * The message code
     * @type {string}
     * @memberof Message
     */
    code?: string;
    /**
     * any additional details
     * @type {{ [key: string]: string; }}
     * @memberof Message
     */
    details?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * Operation performed
     * @type {string}
     * @memberof Operation
     */
    operation: string;
    /**
     * Specify whether the operation was successful
     * @type {boolean}
     * @memberof Operation
     */
    success: boolean;
}
/**
 * 
 * @export
 * @interface OperationConfirmation
 */
export interface OperationConfirmation {
    /**
     * Operation performed
     * @type {string}
     * @memberof OperationConfirmation
     */
    operation: string;
    /**
     * Specify whether the operation was successful
     * @type {boolean}
     * @memberof OperationConfirmation
     */
    success: boolean;
    /**
     * The operation carrier
     * @type {string}
     * @memberof OperationConfirmation
     */
    carrier_name: string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof OperationConfirmation
     */
    carrier_id: string;
}
/**
 * 
 * @export
 * @interface OperationResponse
 */
export interface OperationResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof OperationResponse
     */
    messages?: Array<Message>;
    /**
     * 
     * @type {OperationConfirmation}
     * @memberof OperationResponse
     */
    confirmation?: OperationConfirmation;
}
/**
 * 
 * @export
 * @interface Parcel
 */
export interface Parcel {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Parcel
     */
    id?: string;
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof Parcel
     */
    weight: number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof Parcel
     */
    width?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof Parcel
     */
    height?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof Parcel
     */
    length?: number | null;
    /**
     *  The parcel\'s packaging type.  **Note that the packaging is optional when using a package preset**  values: <br/>- **envelope**<br/>- **pak**<br/>- **tube**<br/>- **pallet**<br/>- **small_box**<br/>- **medium_box**<br/>- **your_packaging**  For specific carriers packaging type, please consult [the reference](#operation/references). 
     * @type {string}
     * @memberof Parcel
     */
    packaging_type?: string | null;
    /**
     *  The parcel\'s package preset.  For specific carriers package preset, please consult [the reference](#operation/references). 
     * @type {string}
     * @memberof Parcel
     */
    package_preset?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof Parcel
     */
    description?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof Parcel
     */
    content?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof Parcel
     */
    is_document?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {string}
     * @memberof Parcel
     */
    weight_unit: ParcelWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     * @type {string}
     * @memberof Parcel
     */
    dimension_unit?: ParcelDimensionUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelWeightUnitEnum {
    kg = 'KG',
    lb = 'LB'
}
/**
    * @export
    * @enum {string}
    */
export enum ParcelDimensionUnitEnum {
    cm = 'CM',
    in = 'IN'
}

/**
 * 
 * @export
 * @interface ParcelData
 */
export interface ParcelData {
    /**
     * The parcel\'s weight
     * @type {number}
     * @memberof ParcelData
     */
    weight: number;
    /**
     * The parcel\'s width
     * @type {number}
     * @memberof ParcelData
     */
    width?: number | null;
    /**
     * The parcel\'s height
     * @type {number}
     * @memberof ParcelData
     */
    height?: number | null;
    /**
     * The parcel\'s length
     * @type {number}
     * @memberof ParcelData
     */
    length?: number | null;
    /**
     *  The parcel\'s packaging type.  **Note that the packaging is optional when using a package preset**  values: <br/>- **envelope**<br/>- **pak**<br/>- **tube**<br/>- **pallet**<br/>- **small_box**<br/>- **medium_box**<br/>- **your_packaging**  For specific carriers packaging type, please consult [the reference](#operation/references). 
     * @type {string}
     * @memberof ParcelData
     */
    packaging_type?: string | null;
    /**
     *  The parcel\'s package preset.  For specific carriers package preset, please consult [the reference](#operation/references). 
     * @type {string}
     * @memberof ParcelData
     */
    package_preset?: string | null;
    /**
     * The parcel\'s description
     * @type {string}
     * @memberof ParcelData
     */
    description?: string | null;
    /**
     * The parcel\'s content description
     * @type {string}
     * @memberof ParcelData
     */
    content?: string | null;
    /**
     * Indicates if the parcel is composed of documents only
     * @type {boolean}
     * @memberof ParcelData
     */
    is_document?: boolean | null;
    /**
     * The parcel\'s weight unit
     * @type {string}
     * @memberof ParcelData
     */
    weight_unit: ParcelDataWeightUnitEnum;
    /**
     * The parcel\'s dimension unit
     * @type {string}
     * @memberof ParcelData
     */
    dimension_unit?: ParcelDataDimensionUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ParcelDataWeightUnitEnum {
    kg = 'KG',
    lb = 'LB'
}
/**
    * @export
    * @enum {string}
    */
export enum ParcelDataDimensionUnitEnum {
    cm = 'CM',
    in = 'IN'
}

/**
 * 
 * @export
 * @interface ParcelList
 */
export interface ParcelList {
    /**
     * 
     * @type {string}
     * @memberof ParcelList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof ParcelList
     */
    previous?: string;
    /**
     * 
     * @type {Array<Parcel>}
     * @memberof ParcelList
     */
    results: Array<Parcel>;
}
/**
 * The payment details
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * The payor type
     * @type {string}
     * @memberof Payment
     */
    paid_by?: PaymentPaidByEnum;
    /**
     * The payment amount currency
     * @type {string}
     * @memberof Payment
     */
    currency?: PaymentCurrencyEnum;
    /**
     * The payor account number
     * @type {string}
     * @memberof Payment
     */
    account_number?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentPaidByEnum {
    sender = 'sender',
    recipient = 'recipient',
    third_party = 'third_party'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentCurrencyEnum {
    eur = 'EUR',
    aed = 'AED',
    usd = 'USD',
    xcd = 'XCD',
    amd = 'AMD',
    ang = 'ANG',
    aoa = 'AOA',
    ars = 'ARS',
    aud = 'AUD',
    awg = 'AWG',
    azn = 'AZN',
    bam = 'BAM',
    bbd = 'BBD',
    bdt = 'BDT',
    xof = 'XOF',
    bgn = 'BGN',
    bhd = 'BHD',
    bif = 'BIF',
    bmd = 'BMD',
    bnd = 'BND',
    bob = 'BOB',
    brl = 'BRL',
    bsd = 'BSD',
    btn = 'BTN',
    bwp = 'BWP',
    byn = 'BYN',
    bzd = 'BZD',
    cad = 'CAD',
    cdf = 'CDF',
    xaf = 'XAF',
    chf = 'CHF',
    nzd = 'NZD',
    clp = 'CLP',
    cny = 'CNY',
    cop = 'COP',
    crc = 'CRC',
    cuc = 'CUC',
    cve = 'CVE',
    czk = 'CZK',
    djf = 'DJF',
    dkk = 'DKK',
    dop = 'DOP',
    dzd = 'DZD',
    egp = 'EGP',
    ern = 'ERN',
    etb = 'ETB',
    fjd = 'FJD',
    gbp = 'GBP',
    gel = 'GEL',
    ghs = 'GHS',
    gmd = 'GMD',
    gnf = 'GNF',
    gtq = 'GTQ',
    gyd = 'GYD',
    hkd = 'HKD',
    hnl = 'HNL',
    hrk = 'HRK',
    htg = 'HTG',
    huf = 'HUF',
    idr = 'IDR',
    ils = 'ILS',
    inr = 'INR',
    irr = 'IRR',
    isk = 'ISK',
    jmd = 'JMD',
    jod = 'JOD',
    jpy = 'JPY',
    kes = 'KES',
    kgs = 'KGS',
    khr = 'KHR',
    kmf = 'KMF',
    kpw = 'KPW',
    krw = 'KRW',
    kwd = 'KWD',
    kyd = 'KYD',
    kzt = 'KZT',
    lak = 'LAK',
    lkr = 'LKR',
    lrd = 'LRD',
    lsl = 'LSL',
    lyd = 'LYD',
    mad = 'MAD',
    mdl = 'MDL',
    mga = 'MGA',
    mkd = 'MKD',
    mmk = 'MMK',
    mnt = 'MNT',
    mop = 'MOP',
    mro = 'MRO',
    mur = 'MUR',
    mvr = 'MVR',
    mwk = 'MWK',
    mxn = 'MXN',
    myr = 'MYR',
    mzn = 'MZN',
    nad = 'NAD',
    xpf = 'XPF',
    ngn = 'NGN',
    nio = 'NIO',
    nok = 'NOK',
    npr = 'NPR',
    omr = 'OMR',
    pen = 'PEN',
    pgk = 'PGK',
    php = 'PHP',
    pkr = 'PKR',
    pln = 'PLN',
    pyg = 'PYG',
    qar = 'QAR',
    rsd = 'RSD',
    rub = 'RUB',
    rwf = 'RWF',
    sar = 'SAR',
    sbd = 'SBD',
    scr = 'SCR',
    sdg = 'SDG',
    sek = 'SEK',
    sgd = 'SGD',
    shp = 'SHP',
    sll = 'SLL',
    sos = 'SOS',
    srd = 'SRD',
    ssp = 'SSP',
    std = 'STD',
    syp = 'SYP',
    szl = 'SZL',
    thb = 'THB',
    tjs = 'TJS',
    tnd = 'TND',
    top = 'TOP',
    try = 'TRY',
    ttd = 'TTD',
    twd = 'TWD',
    tzs = 'TZS',
    uah = 'UAH',
    uyu = 'UYU',
    uzs = 'UZS',
    vef = 'VEF',
    vnd = 'VND',
    vuv = 'VUV',
    wst = 'WST',
    yer = 'YER',
    zar = 'ZAR'
}

/**
 * 
 * @export
 * @interface Pickup
 */
export interface Pickup {
    /**
     * A unique pickup identifier
     * @type {string}
     * @memberof Pickup
     */
    id?: string;
    /**
     * The pickup carrier
     * @type {string}
     * @memberof Pickup
     */
    carrier_name: string;
    /**
     * The pickup carrier configured name
     * @type {string}
     * @memberof Pickup
     */
    carrier_id: string;
    /**
     * The pickup confirmation identifier
     * @type {string}
     * @memberof Pickup
     */
    confirmation_number: string;
    /**
     * The pickup date
     * @type {string}
     * @memberof Pickup
     */
    pickup_date?: string | null;
    /**
     * 
     * @type {Charge}
     * @memberof Pickup
     */
    pickup_charge?: Charge | null;
    /**
     * The pickup expected ready time
     * @type {string}
     * @memberof Pickup
     */
    ready_time?: string | null;
    /**
     * The pickup expected closing or late time
     * @type {string}
     * @memberof Pickup
     */
    closing_time?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Pickup
     */
    address: Address;
    /**
     * The shipment parcels to pickup.
     * @type {Array<Parcel>}
     * @memberof Pickup
     */
    parcels: Array<Parcel> | null;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof Pickup
     */
    instruction?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof Pickup
     */
    package_location?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof Pickup
     */
    options?: object | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Pickup
     */
    test_mode: boolean;
}
/**
 * 
 * @export
 * @interface PickupCancelData
 */
export interface PickupCancelData {
    /**
     * The reason of the pickup cancellation
     * @type {string}
     * @memberof PickupCancelData
     */
    reason?: string;
}
/**
 * 
 * @export
 * @interface PickupCancelRequest
 */
export interface PickupCancelRequest {
    /**
     * The pickup confirmation identifier
     * @type {string}
     * @memberof PickupCancelRequest
     */
    confirmation_number: string;
    /**
     * 
     * @type {AddressData}
     * @memberof PickupCancelRequest
     */
    address?: AddressData;
    /**
     *  The pickup date  Date Format: `YYYY-MM-DD` 
     * @type {string}
     * @memberof PickupCancelRequest
     */
    pickup_date?: string | null;
    /**
     * The reason of the pickup cancellation
     * @type {string}
     * @memberof PickupCancelRequest
     */
    reason?: string;
}
/**
 * 
 * @export
 * @interface PickupData
 */
export interface PickupData {
    /**
     *  The expected pickup date  Date Format: `YYYY-MM-DD` 
     * @type {string}
     * @memberof PickupData
     */
    pickup_date: string;
    /**
     * 
     * @type {AddressData}
     * @memberof PickupData
     */
    address?: AddressData;
    /**
     *  The ready time for pickup.  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupData
     */
    ready_time: string;
    /**
     *  The closing or late time of the pickup  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupData
     */
    closing_time: string;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof PickupData
     */
    instruction?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof PickupData
     */
    package_location?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof PickupData
     */
    options?: object | null;
    /**
     * The list of shipments to be picked up
     * @type {Array<string>}
     * @memberof PickupData
     */
    tracking_numbers: Array<string>;
}
/**
 * 
 * @export
 * @interface PickupList
 */
export interface PickupList {
    /**
     * 
     * @type {string}
     * @memberof PickupList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PickupList
     */
    previous?: string;
    /**
     * 
     * @type {Array<Pickup>}
     * @memberof PickupList
     */
    results: Array<Pickup>;
}
/**
 * 
 * @export
 * @interface PickupRequest
 */
export interface PickupRequest {
    /**
     *  The expected pickup date  Date Format: `YYYY-MM-DD` 
     * @type {string}
     * @memberof PickupRequest
     */
    pickup_date: string;
    /**
     * 
     * @type {AddressData}
     * @memberof PickupRequest
     */
    address: AddressData;
    /**
     * The shipment parcels to pickup.
     * @type {Array<ParcelData>}
     * @memberof PickupRequest
     */
    parcels: Array<ParcelData> | null;
    /**
     *  The ready time for pickup.  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupRequest
     */
    ready_time: string;
    /**
     *  The closing or late time of the pickup  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupRequest
     */
    closing_time: string;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof PickupRequest
     */
    instruction?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof PickupRequest
     */
    package_location?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof PickupRequest
     */
    options?: object | null;
}
/**
 * 
 * @export
 * @interface PickupResponse
 */
export interface PickupResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof PickupResponse
     */
    messages?: Array<Message>;
    /**
     * 
     * @type {Pickup}
     * @memberof PickupResponse
     */
    pickup?: Pickup;
}
/**
 * 
 * @export
 * @interface PickupUpdateData
 */
export interface PickupUpdateData {
    /**
     *  The expected pickup date  Date Format: YYYY-MM-DD 
     * @type {string}
     * @memberof PickupUpdateData
     */
    pickup_date?: string;
    /**
     * 
     * @type {AddressData}
     * @memberof PickupUpdateData
     */
    address?: AddressData;
    /**
     * The ready time for pickup.
     * @type {string}
     * @memberof PickupUpdateData
     */
    ready_time?: string | null;
    /**
     * The closing or late time of the pickup
     * @type {string}
     * @memberof PickupUpdateData
     */
    closing_time?: string | null;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof PickupUpdateData
     */
    instruction?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof PickupUpdateData
     */
    package_location?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof PickupUpdateData
     */
    options?: object | null;
    /**
     * The list of shipments to be picked up
     * @type {Array<string>}
     * @memberof PickupUpdateData
     */
    tracking_numbers?: Array<string>;
    /**
     * pickup identification number
     * @type {string}
     * @memberof PickupUpdateData
     */
    confirmation_number: string;
}
/**
 * 
 * @export
 * @interface PickupUpdateRequest
 */
export interface PickupUpdateRequest {
    /**
     *  The expected pickup date  Date Format: `YYYY-MM-DD` 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    pickup_date: string;
    /**
     * 
     * @type {Address}
     * @memberof PickupUpdateRequest
     */
    address: Address;
    /**
     * The shipment parcels to pickup.
     * @type {Array<Parcel>}
     * @memberof PickupUpdateRequest
     */
    parcels: Array<Parcel> | null;
    /**
     * pickup identification number
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    confirmation_number: string;
    /**
     *  The ready time for pickup.  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    ready_time: string;
    /**
     *  The closing or late time of the pickup  Time Format: `HH:MM` 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    closing_time: string;
    /**
     *  The pickup instruction.  eg: Handle with care. 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    instruction?: string | null;
    /**
     *  The package(s) location.  eg: Behind the entrance door. 
     * @type {string}
     * @memberof PickupUpdateRequest
     */
    package_location?: string | null;
    /**
     * Advanced carrier specific pickup options
     * @type {object}
     * @memberof PickupUpdateRequest
     */
    options?: object | null;
}
/**
 * The list of returned rates
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Rate
     */
    id?: string;
    /**
     * The rate\'s carrier
     * @type {string}
     * @memberof Rate
     */
    carrier_name: string;
    /**
     * The targeted carrier\'s name (unique identifier)
     * @type {string}
     * @memberof Rate
     */
    carrier_id: string;
    /**
     * The rate monetary values currency code
     * @type {string}
     * @memberof Rate
     */
    currency: string;
    /**
     * The carrier\'s rate (quote) service
     * @type {string}
     * @memberof Rate
     */
    service?: string | null;
    /**
     * The monetary amount of the discount on the rate
     * @type {number}
     * @memberof Rate
     */
    discount?: number | null;
    /**
     *  The rate\'s monetary amount of the base charge.<br/> This is the net amount of the rate before additional charges 
     * @type {number}
     * @memberof Rate
     */
    base_charge?: number;
    /**
     *  The rate\'s monetary amount of the total charge.<br/> This is the gross amount of the rate after adding the additional charges 
     * @type {number}
     * @memberof Rate
     */
    total_charge?: number;
    /**
     * The monetary amount of the duties and taxes if applied
     * @type {number}
     * @memberof Rate
     */
    duties_and_taxes?: number | null;
    /**
     * The estimated delivery transit days
     * @type {number}
     * @memberof Rate
     */
    transit_days?: number | null;
    /**
     * list of the rate\'s additional charges
     * @type {Array<Charge>}
     * @memberof Rate
     */
    extra_charges?: Array<Charge>;
    /**
     * provider specific metadata
     * @type {object}
     * @memberof Rate
     */
    meta?: object | null;
    /**
     * The system carrier configuration id
     * @type {string}
     * @memberof Rate
     */
    carrier_ref?: string | null;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Rate
     */
    test_mode: boolean;
}
/**
 * 
 * @export
 * @interface RateRequest
 */
export interface RateRequest {
    /**
     * 
     * @type {AddressData}
     * @memberof RateRequest
     */
    shipper: AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof RateRequest
     */
    recipient: AddressData;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof RateRequest
     */
    parcels: Array<ParcelData>;
    /**
     *  The requested carrier service for the shipment.<br/> Please consult [the reference](#operation/references) for specific carriers services.  Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
     * @type {Array<string>}
     * @memberof RateRequest
     */
    services?: Array<string> | null;
    /**
     *  The options available for the shipment.  Please consult [the reference](#operation/references) for additional specific carriers options. 
     * @type {object}
     * @memberof RateRequest
     */
    options?: object | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof RateRequest
     */
    reference?: string | null;
    /**
     *  The list of configured carriers you wish to get rates from. 
     * @type {Array<string>}
     * @memberof RateRequest
     */
    carrier_ids?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface RateResponse
 */
export interface RateResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof RateResponse
     */
    messages?: Array<Message>;
    /**
     * The list of returned rates
     * @type {Array<Rate>}
     * @memberof RateResponse
     */
    rates: Array<Rate>;
}
/**
 * 
 * @export
 * @interface References
 */
export interface References {
    /**
     * 
     * @type {string}
     * @memberof References
     */
    APP_NAME: string;
    /**
     * 
     * @type {string}
     * @memberof References
     */
    APP_VERSION: string;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    countries: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    currencies: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    carriers: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    customs_content_type: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    incoterms: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    states: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    services: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    service_names: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    options: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    option_names: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    package_presets: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    packaging_types: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    payment_types: object;
    /**
     * 
     * @type {object}
     * @memberof References
     */
    carrier_capabilities: object;
}
/**
 * 
 * @export
 * @interface Shipment
 */
export interface Shipment {
    /**
     * A unique identifier
     * @type {string}
     * @memberof Shipment
     */
    id?: string;
    /**
     * The current Shipment status
     * @type {string}
     * @memberof Shipment
     */
    status?: ShipmentStatusEnum;
    /**
     * The shipment carrier
     * @type {string}
     * @memberof Shipment
     */
    carrier_name?: string | null;
    /**
     * The shipment carrier configured identifier
     * @type {string}
     * @memberof Shipment
     */
    carrier_id?: string | null;
    /**
     * The shipment label in base64 string
     * @type {string}
     * @memberof Shipment
     */
    label?: string | null;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof Shipment
     */
    tracking_number?: string | null;
    /**
     * The shipment carrier system identifier
     * @type {string}
     * @memberof Shipment
     */
    shipment_identifier?: string | null;
    /**
     * 
     * @type {Rate}
     * @memberof Shipment
     */
    selected_rate?: Rate;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof Shipment
     */
    selected_rate_id?: string | null;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof Shipment
     */
    rates?: Array<Rate>;
    /**
     * The shipment tracking url
     * @type {string}
     * @memberof Shipment
     */
    tracking_url?: string | null;
    /**
     * The selected service
     * @type {string}
     * @memberof Shipment
     */
    service?: string | null;
    /**
     * 
     * @type {Address}
     * @memberof Shipment
     */
    shipper: Address;
    /**
     * 
     * @type {Address}
     * @memberof Shipment
     */
    recipient: Address;
    /**
     * The shipment\'s parcels
     * @type {Array<Parcel>}
     * @memberof Shipment
     */
    parcels: Array<Parcel>;
    /**
     *  The carriers services requested for the shipment.  Please consult [the reference](#operation/references) for specific carriers services.<br/> Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
     * @type {Array<string>}
     * @memberof Shipment
     */
    services?: Array<string> | null;
    /**
     *  The options available for the shipment.<br/> Please consult [the reference](#operation/references) for additional specific carriers options. 
     * @type {object}
     * @memberof Shipment
     */
    options?: object | null;
    /**
     * 
     * @type {Payment}
     * @memberof Shipment
     */
    payment?: Payment;
    /**
     * 
     * @type {Customs}
     * @memberof Shipment
     */
    customs?: Customs;
    /**
     * The shipment reference
     * @type {string}
     * @memberof Shipment
     */
    reference?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof Shipment
     */
    label_type?: ShipmentLabelTypeEnum;
    /**
     *  The list of configured carriers you wish to get rates from.  *Note that the request will be sent to all carriers in nothing is specified* 
     * @type {Array<string>}
     * @memberof Shipment
     */
    carrier_ids?: Array<string> | null;
    /**
     * The attached tracker id
     * @type {string}
     * @memberof Shipment
     */
    tracker_id?: string | null;
    /**
     *  The shipment creation datetime  Date Format: `YYYY-MM-DD HH:MM:SS.mmmmmmz` 
     * @type {string}
     * @memberof Shipment
     */
    created_at: string;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Shipment
     */
    test_mode: boolean;
    /**
     * provider specific metadata
     * @type {object}
     * @memberof Shipment
     */
    meta?: object | null;
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof Shipment
     */
    messages?: Array<Message>;
}

/**
    * @export
    * @enum {string}
    */
export enum ShipmentStatusEnum {
    created = 'created',
    purchased = 'purchased',
    cancelled = 'cancelled',
    shipped = 'shipped',
    in_transit = 'in-transit',
    delivered = 'delivered'
}
/**
    * @export
    * @enum {string}
    */
export enum ShipmentLabelTypeEnum {
    pdf = 'PDF',
    zpl = 'ZPL'
}

/**
 * 
 * @export
 * @interface ShipmentCancelRequest
 */
export interface ShipmentCancelRequest {
    /**
     * The shipment identifier returned during creation
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    shipment_identifier: string;
    /**
     * The selected shipment service
     * @type {string}
     * @memberof ShipmentCancelRequest
     */
    service?: string | null;
    /**
     * Advanced carrier specific cancellation options
     * @type {object}
     * @memberof ShipmentCancelRequest
     */
    options?: object | null;
}
/**
 * 
 * @export
 * @interface ShipmentData
 */
export interface ShipmentData {
    /**
     * 
     * @type {AddressData}
     * @memberof ShipmentData
     */
    shipper: AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof ShipmentData
     */
    recipient: AddressData;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof ShipmentData
     */
    parcels: Array<ParcelData>;
    /**
     *  The options available for the shipment.<br/> Please consult [the reference](#operation/references) for additional specific carriers options. 
     * @type {object}
     * @memberof ShipmentData
     */
    options?: object | null;
    /**
     * 
     * @type {Payment}
     * @memberof ShipmentData
     */
    payment?: Payment;
    /**
     * 
     * @type {CustomsData}
     * @memberof ShipmentData
     */
    customs?: CustomsData;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentData
     */
    reference?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShipmentData
     */
    label_type?: ShipmentDataLabelTypeEnum;
    /**
     *  The requested carrier service for the shipment.  Please consult [the reference](#operation/references) for specific carriers services.<br/> Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
     * @type {Array<string>}
     * @memberof ShipmentData
     */
    services?: Array<string> | null;
    /**
     *  The list of configured carriers you wish to get rates from.  *Note that the request will be sent to all carriers in nothing is specified* 
     * @type {Array<string>}
     * @memberof ShipmentData
     */
    carrier_ids?: Array<string> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ShipmentDataLabelTypeEnum {
    pdf = 'PDF',
    zpl = 'ZPL'
}

/**
 * 
 * @export
 * @interface ShipmentList
 */
export interface ShipmentList {
    /**
     * 
     * @type {string}
     * @memberof ShipmentList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof ShipmentList
     */
    previous?: string;
    /**
     * 
     * @type {Array<Shipment>}
     * @memberof ShipmentList
     */
    results: Array<Shipment>;
}
/**
 * 
 * @export
 * @interface ShipmentPurchaseData
 */
export interface ShipmentPurchaseData {
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    selected_rate_id: string;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    label_type?: ShipmentPurchaseDataLabelTypeEnum;
    /**
     * 
     * @type {Payment}
     * @memberof ShipmentPurchaseData
     */
    payment?: Payment;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentPurchaseData
     */
    reference?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ShipmentPurchaseDataLabelTypeEnum {
    pdf = 'PDF',
    zpl = 'ZPL'
}

/**
 * 
 * @export
 * @interface ShipmentRateData
 */
export interface ShipmentRateData {
    /**
     *  The requested carrier service for the shipment.  Please consult [the reference](#operation/references) for specific carriers services.<br/> Note that this is a list because on a Multi-carrier rate request you could specify a service per carrier. 
     * @type {Array<string>}
     * @memberof ShipmentRateData
     */
    services?: Array<string> | null;
    /**
     *  The list of configured carriers you wish to get rates from.  *Note that the request will be sent to all carriers in nothing is specified* 
     * @type {Array<string>}
     * @memberof ShipmentRateData
     */
    carrier_ids?: Array<string> | null;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShipmentRateData
     */
    reference?: string | null;
}
/**
 * 
 * @export
 * @interface ShippingRequest
 */
export interface ShippingRequest {
    /**
     * 
     * @type {AddressData}
     * @memberof ShippingRequest
     */
    shipper: AddressData;
    /**
     * 
     * @type {AddressData}
     * @memberof ShippingRequest
     */
    recipient: AddressData;
    /**
     * The shipment\'s parcels
     * @type {Array<ParcelData>}
     * @memberof ShippingRequest
     */
    parcels: Array<ParcelData>;
    /**
     *  The options available for the shipment.<br/> Please consult [the reference](#operation/references) for additional specific carriers options. 
     * @type {object}
     * @memberof ShippingRequest
     */
    options?: object | null;
    /**
     * 
     * @type {Payment}
     * @memberof ShippingRequest
     */
    payment: Payment;
    /**
     * 
     * @type {CustomsData}
     * @memberof ShippingRequest
     */
    customs?: CustomsData;
    /**
     * The shipment reference
     * @type {string}
     * @memberof ShippingRequest
     */
    reference?: string | null;
    /**
     * The shipment label file type.
     * @type {string}
     * @memberof ShippingRequest
     */
    label_type?: ShippingRequestLabelTypeEnum;
    /**
     * The shipment selected rate.
     * @type {string}
     * @memberof ShippingRequest
     */
    selected_rate_id: string;
    /**
     * The list for shipment rates fetched previously
     * @type {Array<Rate>}
     * @memberof ShippingRequest
     */
    rates: Array<Rate>;
}

/**
    * @export
    * @enum {string}
    */
export enum ShippingRequestLabelTypeEnum {
    pdf = 'PDF',
    zpl = 'ZPL'
}

/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    password: string;
    /**
     *  **should be specified only in a multi-org deployment.**  Note the first org related to the user is selected by default. 
     * @type {string}
     * @memberof TokenObtainPair
     */
    org_id?: string;
}
/**
 * 
 * @export
 * @interface TokenPair
 */
export interface TokenPair {
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    access: string;
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    refresh: string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    refresh: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    access?: string;
}
/**
 * 
 * @export
 * @interface TokenVerify
 */
export interface TokenVerify {
    /**
     * 
     * @type {string}
     * @memberof TokenVerify
     */
    token: string;
}
/**
 * 
 * @export
 * @interface TrackerList
 */
export interface TrackerList {
    /**
     * 
     * @type {string}
     * @memberof TrackerList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof TrackerList
     */
    previous?: string;
    /**
     * 
     * @type {Array<TrackingStatus>}
     * @memberof TrackerList
     */
    results: Array<TrackingStatus>;
}
/**
 * The tracking details events
 * @export
 * @interface TrackingEvent
 */
export interface TrackingEvent {
    /**
     * The tracking event\'s date
     * @type {string}
     * @memberof TrackingEvent
     */
    date?: string;
    /**
     * The tracking event\'s description
     * @type {string}
     * @memberof TrackingEvent
     */
    description?: string;
    /**
     * The tracking event\'s location
     * @type {string}
     * @memberof TrackingEvent
     */
    location?: string;
    /**
     * The tracking event\'s code
     * @type {string}
     * @memberof TrackingEvent
     */
    code?: string | null;
    /**
     * The tracking event\'s time
     * @type {string}
     * @memberof TrackingEvent
     */
    time?: string | null;
}
/**
 * 
 * @export
 * @interface TrackingResponse
 */
export interface TrackingResponse {
    /**
     * The list of note or warning messages
     * @type {Array<Message>}
     * @memberof TrackingResponse
     */
    messages?: Array<Message>;
    /**
     * 
     * @type {TrackingStatus}
     * @memberof TrackingResponse
     */
    tracking?: TrackingStatus;
}
/**
 * The tracking details retrieved
 * @export
 * @interface TrackingStatus
 */
export interface TrackingStatus {
    /**
     * A unique identifier
     * @type {string}
     * @memberof TrackingStatus
     */
    id?: string;
    /**
     * The tracking carrier
     * @type {string}
     * @memberof TrackingStatus
     */
    carrier_name: string;
    /**
     * The tracking carrier configured identifier
     * @type {string}
     * @memberof TrackingStatus
     */
    carrier_id: string;
    /**
     * The shipment tracking number
     * @type {string}
     * @memberof TrackingStatus
     */
    tracking_number: string;
    /**
     * The tracking details events
     * @type {Array<TrackingEvent>}
     * @memberof TrackingStatus
     */
    events?: Array<TrackingEvent> | null;
    /**
     * Specified whether the related shipment was delivered
     * @type {boolean}
     * @memberof TrackingStatus
     */
    delivered?: boolean;
    /**
     * Specified whether the object was created with a carrier in test mode
     * @type {boolean}
     * @memberof TrackingStatus
     */
    test_mode: boolean;
    /**
     * The current tracking status
     * @type {string}
     * @memberof TrackingStatus
     */
    status?: TrackingStatusStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TrackingStatusStatusEnum {
    created = 'created',
    purchased = 'purchased',
    cancelled = 'cancelled',
    shipped = 'shipped',
    in_transit = 'in-transit',
    delivered = 'delivered'
}

/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof Webhook
     */
    url: string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof Webhook
     */
    description?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<string>}
     * @memberof Webhook
     */
    enabled_events: Array<WebhookEnabledEventsEnum>;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof Webhook
     */
    test_mode: boolean;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof Webhook
     */
    disabled?: boolean | null;
    /**
     * A unique identifier
     * @type {string}
     * @memberof Webhook
     */
    id?: string;
    /**
     * The datetime of the last event sent.
     * @type {string}
     * @memberof Webhook
     */
    last_event_at?: string | null;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookEnabledEventsEnum {
    all = 'all',
    shipment_purchased = 'shipment.purchased',
    shipment_cancelled = 'shipment.cancelled',
    shipment_fulfilled = 'shipment.fulfilled',
    tracker_created = 'tracker.created',
    tracker_updated = 'tracker.updated'
}

/**
 * 
 * @export
 * @interface WebhookData
 */
export interface WebhookData {
    /**
     * The URL of the webhook endpoint.
     * @type {string}
     * @memberof WebhookData
     */
    url: string;
    /**
     * An optional description of what the webhook is used for.
     * @type {string}
     * @memberof WebhookData
     */
    description?: string | null;
    /**
     * The list of events to enable for this endpoint.
     * @type {Array<string>}
     * @memberof WebhookData
     */
    enabled_events: Array<WebhookDataEnabledEventsEnum>;
    /**
     * Specified whether it was created with a carrier in test mode
     * @type {boolean}
     * @memberof WebhookData
     */
    test_mode: boolean;
    /**
     * Indicates that the webhook is disabled
     * @type {boolean}
     * @memberof WebhookData
     */
    disabled?: boolean | null;
}

/**
    * @export
    * @enum {string}
    */
export enum WebhookDataEnabledEventsEnum {
    all = 'all',
    shipment_purchased = 'shipment.purchased',
    shipment_cancelled = 'shipment.cancelled',
    shipment_fulfilled = 'shipment.fulfilled',
    tracker_created = 'tracker.created',
    tracker_updated = 'tracker.updated'
}

/**
 * 
 * @export
 * @interface WebhookList
 */
export interface WebhookList {
    /**
     * 
     * @type {string}
     * @memberof WebhookList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookList
     */
    previous?: string;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookList
     */
    results: Array<Webhook>;
}
/**
 * 
 * @export
 * @interface WebhookTestRequest
 */
export interface WebhookTestRequest {
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequest
     */
    payload: object;
}

/**
 * APIApi - axios parameter creator
 * @export
 */
export const APIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (data: TokenObtainPair, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('authenticate', 'data', data)
            const localVarPath = `/api/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/references`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (data: TokenRefresh, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('refreshToken', 'data', data)
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify an existent authentication token
         * @summary Verify auth token
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken: async (data: TokenVerify, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('verifyToken', 'data', data)
            const localVarPath = `/api/token/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(data: TokenObtainPair, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async data(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<References>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.data(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(data: TokenRefresh, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Verify an existent authentication token
         * @summary Verify auth token
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyToken(data: TokenVerify, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyToken(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIApiFp(configuration)
    return {
        /**
         * Authenticate the user and return a token pair
         * @summary Obtain auth token pair
         * @param {TokenObtainPair} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(data: TokenObtainPair, options?: any): AxiosPromise<TokenPair> {
            return localVarFp.authenticate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Data References
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        data(options?: any): AxiosPromise<References> {
            return localVarFp.data(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate the user and return a token pair
         * @summary Refresh auth token
         * @param {TokenRefresh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(data: TokenRefresh, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.refreshToken(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify an existent authentication token
         * @summary Verify auth token
         * @param {TokenVerify} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyToken(data: TokenVerify, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.verifyToken(data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
    /**
     * Authenticate the user and return a token pair
     * @summary Obtain auth token pair
     * @param {TokenObtainPair} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public authenticate(data: TokenObtainPair, options?: any) {
        return APIApiFp(this.configuration).authenticate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Data References
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public data(options?: any) {
        return APIApiFp(this.configuration).data(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate the user and return a token pair
     * @summary Refresh auth token
     * @param {TokenRefresh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public refreshToken(data: TokenRefresh, options?: any) {
        return APIApiFp(this.configuration).refreshToken(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify an existent authentication token
     * @summary Verify auth token
     * @param {TokenVerify} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public verifyToken(data: TokenVerify, options?: any) {
        return APIApiFp(this.configuration).verifyToken(data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: AddressData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: AddressData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/addresses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: AddressData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: AddressData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Address>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressesApiFp(configuration)
    return {
        /**
         * Create a new address.
         * @summary Create an address
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: AddressData, options?: any): AxiosPromise<Address> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard an address.
         * @summary Discard an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(id: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.discard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all addresses.
         * @summary List all addresses
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, options?: any): AxiosPromise<AddressList> {
            return localVarFp.list(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an address.
         * @summary Retrieve an address
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Address> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update an address.
         * @summary Update an address
         * @param {string} id 
         * @param {AddressData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: AddressData, options?: any): AxiosPromise<Address> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * Create a new address.
     * @summary Create an address
     * @param {AddressData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public create(data: AddressData, options?: any) {
        return AddressesApiFp(this.configuration).create(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard an address.
     * @summary Discard an address
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public discard(id: string, options?: any) {
        return AddressesApiFp(this.configuration).discard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all addresses.
     * @summary List all addresses
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public list(limit?: number, offset?: number, options?: any) {
        return AddressesApiFp(this.configuration).list(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an address.
     * @summary Retrieve an address
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public retrieve(id: string, options?: any) {
        return AddressesApiFp(this.configuration).retrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update an address.
     * @summary Update an address
     * @param {string} id 
     * @param {AddressData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public update(id: string, data: AddressData, options?: any) {
        return AddressesApiFp(this.configuration).update(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CarriersApi - axios parameter creator
 * @export
 */
export const CarriersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'eshipper' | 'fedex' | 'freightcom' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] Indicates a carrier (type)
         * @param {boolean} [test] This flag filter out carriers in test or prod mode
         * @param {boolean} [active] This flag indicates whether to return active carriers only
         * @param {boolean} [systemOnly] This flag indicates that only system carriers should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'eshipper' | 'fedex' | 'freightcom' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', test?: boolean, active?: boolean, systemOnly?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/carriers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (systemOnly !== undefined) {
                localVarQueryParameter['system_only'] = systemOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarriersApi - functional programming interface
 * @export
 */
export const CarriersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarriersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'eshipper' | 'fedex' | 'freightcom' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] Indicates a carrier (type)
         * @param {boolean} [test] This flag filter out carriers in test or prod mode
         * @param {boolean} [active] This flag indicates whether to return active carriers only
         * @param {boolean} [systemOnly] This flag indicates that only system carriers should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'eshipper' | 'fedex' | 'freightcom' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', test?: boolean, active?: boolean, systemOnly?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarrierList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, carrierName, test, active, systemOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CarriersApi - factory interface
 * @export
 */
export const CarriersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarriersApiFp(configuration)
    return {
        /**
         * Returns the list of configured carriers
         * @summary List all carriers
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'eshipper' | 'fedex' | 'freightcom' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] Indicates a carrier (type)
         * @param {boolean} [test] This flag filter out carriers in test or prod mode
         * @param {boolean} [active] This flag indicates whether to return active carriers only
         * @param {boolean} [systemOnly] This flag indicates that only system carriers should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'eshipper' | 'fedex' | 'freightcom' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', test?: boolean, active?: boolean, systemOnly?: boolean, options?: any): AxiosPromise<CarrierList> {
            return localVarFp.list(limit, offset, carrierName, test, active, systemOnly, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CarriersApi - object-oriented interface
 * @export
 * @class CarriersApi
 * @extends {BaseAPI}
 */
export class CarriersApi extends BaseAPI {
    /**
     * Returns the list of configured carriers
     * @summary List all carriers
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'eshipper' | 'fedex' | 'freightcom' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress'} [carrierName] Indicates a carrier (type)
     * @param {boolean} [test] This flag filter out carriers in test or prod mode
     * @param {boolean} [active] This flag indicates whether to return active carriers only
     * @param {boolean} [systemOnly] This flag indicates that only system carriers should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarriersApi
     */
    public list(limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'eshipper' | 'fedex' | 'freightcom' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress', test?: boolean, active?: boolean, systemOnly?: boolean, options?: any) {
        return CarriersApiFp(this.configuration).list(limit, offset, carrierName, test, active, systemOnly, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomsApi - axios parameter creator
 * @export
 */
export const CustomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a customs commodity.
         * @summary Add a commodity
         * @param {string} id 
         * @param {CommodityData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCommodity: async (id: string, data: CommodityData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addCommodity', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('addCommodity', 'data', data)
            const localVarPath = `/v1/customs_info/{id}/commodities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new customs declaration.
         * @summary Create a customs info
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: CustomsData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/customs_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard a customs declaration.
         * @summary Discard a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/customs_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard a customs commodity.
         * @summary Discard a commodity
         * @param {string} ck 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discardCommodity: async (ck: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ck' is not null or undefined
            assertParamExists('discardCommodity', 'ck', ck)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discardCommodity', 'id', id)
            const localVarPath = `/v1/customs_info/{id}/commodities/{ck}`
                .replace(`{${"ck"}}`, encodeURIComponent(String(ck)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all stored customs declarations.
         * @summary List all customs info
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customs_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve customs declaration.
         * @summary Retrieve a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/customs_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * modify an existing customs declaration.
         * @summary Update a customs info
         * @param {string} id 
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: CustomsData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/customs_info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomsApi - functional programming interface
 * @export
 */
export const CustomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a customs commodity.
         * @summary Add a commodity
         * @param {string} id 
         * @param {CommodityData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCommodity(id: string, data: CommodityData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCommodity(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new customs declaration.
         * @summary Create a customs info
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: CustomsData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard a customs declaration.
         * @summary Discard a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard a customs commodity.
         * @summary Discard a commodity
         * @param {string} ck 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discardCommodity(ck: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discardCommodity(ck, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all stored customs declarations.
         * @summary List all customs info
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve customs declaration.
         * @summary Retrieve a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * modify an existing customs declaration.
         * @summary Update a customs info
         * @param {string} id 
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: CustomsData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomsApi - factory interface
 * @export
 */
export const CustomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomsApiFp(configuration)
    return {
        /**
         * Add a customs commodity.
         * @summary Add a commodity
         * @param {string} id 
         * @param {CommodityData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCommodity(id: string, data: CommodityData, options?: any): AxiosPromise<Customs> {
            return localVarFp.addCommodity(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new customs declaration.
         * @summary Create a customs info
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: CustomsData, options?: any): AxiosPromise<Customs> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard a customs declaration.
         * @summary Discard a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(id: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.discard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard a customs commodity.
         * @summary Discard a commodity
         * @param {string} ck 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discardCommodity(ck: string, id: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.discardCommodity(ck, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all stored customs declarations.
         * @summary List all customs info
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, options?: any): AxiosPromise<CustomsList> {
            return localVarFp.list(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve customs declaration.
         * @summary Retrieve a customs info
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Customs> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * modify an existing customs declaration.
         * @summary Update a customs info
         * @param {string} id 
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: CustomsData, options?: any): AxiosPromise<Customs> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomsApi - object-oriented interface
 * @export
 * @class CustomsApi
 * @extends {BaseAPI}
 */
export class CustomsApi extends BaseAPI {
    /**
     * Add a customs commodity.
     * @summary Add a commodity
     * @param {string} id 
     * @param {CommodityData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public addCommodity(id: string, data: CommodityData, options?: any) {
        return CustomsApiFp(this.configuration).addCommodity(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new customs declaration.
     * @summary Create a customs info
     * @param {CustomsData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public create(data: CustomsData, options?: any) {
        return CustomsApiFp(this.configuration).create(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard a customs declaration.
     * @summary Discard a customs info
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public discard(id: string, options?: any) {
        return CustomsApiFp(this.configuration).discard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard a customs commodity.
     * @summary Discard a commodity
     * @param {string} ck 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public discardCommodity(ck: string, id: string, options?: any) {
        return CustomsApiFp(this.configuration).discardCommodity(ck, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all stored customs declarations.
     * @summary List all customs info
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public list(limit?: number, offset?: number, options?: any) {
        return CustomsApiFp(this.configuration).list(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve customs declaration.
     * @summary Retrieve a customs info
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public retrieve(id: string, options?: any) {
        return CustomsApiFp(this.configuration).retrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * modify an existing customs declaration.
     * @summary Update a customs info
     * @param {string} id 
     * @param {CustomsData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomsApi
     */
    public update(id: string, data: CustomsData, options?: any) {
        return CustomsApiFp(this.configuration).update(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ParcelsApi - axios parameter creator
 * @export
 */
export const ParcelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: ParcelData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discard', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/parcels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: ParcelData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/parcels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParcelsApi - functional programming interface
 * @export
 */
export const ParcelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ParcelsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: ParcelData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discard(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParcelList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: ParcelData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Parcel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ParcelsApi - factory interface
 * @export
 */
export const ParcelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ParcelsApiFp(configuration)
    return {
        /**
         * Create a new parcel.
         * @summary Create a parcel
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: ParcelData, options?: any): AxiosPromise<Parcel> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a parcel.
         * @summary Remove a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discard(id: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.discard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all stored parcels.
         * @summary List all parcels
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, options?: any): AxiosPromise<ParcelList> {
            return localVarFp.list(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a parcel.
         * @summary Retrieve a parcel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Parcel> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * modify an existing parcel\'s details.
         * @summary Update a parcel
         * @param {string} id 
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: ParcelData, options?: any): AxiosPromise<Parcel> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ParcelsApi - object-oriented interface
 * @export
 * @class ParcelsApi
 * @extends {BaseAPI}
 */
export class ParcelsApi extends BaseAPI {
    /**
     * Create a new parcel.
     * @summary Create a parcel
     * @param {ParcelData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public create(data: ParcelData, options?: any) {
        return ParcelsApiFp(this.configuration).create(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a parcel.
     * @summary Remove a parcel
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public discard(id: string, options?: any) {
        return ParcelsApiFp(this.configuration).discard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all stored parcels.
     * @summary List all parcels
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public list(limit?: number, offset?: number, options?: any) {
        return ParcelsApiFp(this.configuration).list(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a parcel.
     * @summary Retrieve a parcel
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public retrieve(id: string, options?: any) {
        return ParcelsApiFp(this.configuration).retrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * modify an existing parcel\'s details.
     * @summary Update a parcel
     * @param {string} id 
     * @param {ParcelData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParcelsApi
     */
    public update(id: string, data: ParcelData, options?: any) {
        return ParcelsApiFp(this.configuration).update(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PickupsApi - axios parameter creator
 * @export
 */
export const PickupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, data: PickupCancelData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('cancel', 'data', data)
            const localVarPath = `/v1/pickups/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {boolean} [testMode] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (testMode?: boolean, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/pickups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule: async (carrierName: string, data: PickupData, test?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedule', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('schedule', 'data', data)
            const localVarPath = `/v1/pickups/{carrier_name}/schedule`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: PickupUpdateData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/pickups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PickupsApi - functional programming interface
 * @export
 */
export const PickupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PickupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, data: PickupCancelData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationConfirmation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {boolean} [testMode] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(testMode?: boolean, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(testMode, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedule(carrierName: string, data: PickupData, test?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pickup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedule(carrierName, data, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: PickupUpdateData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationConfirmation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PickupsApi - factory interface
 * @export
 */
export const PickupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PickupsApiFp(configuration)
    return {
        /**
         * Cancel a pickup of one or more shipments.
         * @summary Cancel a pickup
         * @param {string} id 
         * @param {PickupCancelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, data: PickupCancelData, options?: any): AxiosPromise<OperationConfirmation> {
            return localVarFp.cancel(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all scheduled pickups.
         * @summary List shipment pickups
         * @param {boolean} [testMode] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(testMode?: boolean, limit?: number, offset?: number, options?: any): AxiosPromise<PickupList> {
            return localVarFp.list(testMode, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a scheduled pickup.
         * @summary Retrieve a pickup
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Pickup> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule a pickup for one or many shipments with labels already purchased.
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupData} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedule(carrierName: string, data: PickupData, test?: boolean, options?: any): AxiosPromise<Pickup> {
            return localVarFp.schedule(carrierName, data, test, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a pickup for one or many shipments with labels already purchased.
         * @summary Update a pickup
         * @param {string} id 
         * @param {PickupUpdateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: PickupUpdateData, options?: any): AxiosPromise<OperationConfirmation> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PickupsApi - object-oriented interface
 * @export
 * @class PickupsApi
 * @extends {BaseAPI}
 */
export class PickupsApi extends BaseAPI {
    /**
     * Cancel a pickup of one or more shipments.
     * @summary Cancel a pickup
     * @param {string} id 
     * @param {PickupCancelData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public cancel(id: string, data: PickupCancelData, options?: any) {
        return PickupsApiFp(this.configuration).cancel(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all scheduled pickups.
     * @summary List shipment pickups
     * @param {boolean} [testMode] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public list(testMode?: boolean, limit?: number, offset?: number, options?: any) {
        return PickupsApiFp(this.configuration).list(testMode, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a scheduled pickup.
     * @summary Retrieve a pickup
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public retrieve(id: string, options?: any) {
        return PickupsApiFp(this.configuration).retrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule a pickup for one or many shipments with labels already purchased.
     * @summary Schedule a pickup
     * @param {string} carrierName 
     * @param {PickupData} data 
     * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public schedule(carrierName: string, data: PickupData, test?: boolean, options?: any) {
        return PickupsApiFp(this.configuration).schedule(carrierName, data, test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a pickup for one or many shipments with labels already purchased.
     * @summary Update a pickup
     * @param {string} id 
     * @param {PickupUpdateData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PickupsApi
     */
    public update(id: string, data: PickupUpdateData, options?: any) {
        return PickupsApiFp(this.configuration).update(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProxyApi - axios parameter creator
 * @export
 */
export const ProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel: async (data: ShippingRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('buyLabel', 'data', data)
            const localVarPath = `/v1/proxy/shipping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {string} carrierName 
         * @param {PickupCancelRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup: async (carrierName: string, data: PickupCancelRequest, test?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('cancelPickup', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('cancelPickup', 'data', data)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates: async (data: RateRequest, test?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('fetchRates', 'data', data)
            const localVarPath = `/v1/proxy/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup: async (carrierName: string, data: PickupRequest, test?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('schedulePickup', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('schedulePickup', 'data', data)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {string} carrierName 
         * @param {string} trackingNumber 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackShipment: async (carrierName: string, trackingNumber: string, test?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('trackShipment', 'carrierName', carrierName)
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('trackShipment', 'trackingNumber', trackingNumber)
            const localVarPath = `/v1/proxy/tracking/{carrier_name}/{tracking_number}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {string} carrierName 
         * @param {PickupUpdateRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup: async (carrierName: string, data: PickupUpdateRequest, test?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('updatePickup', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('updatePickup', 'data', data)
            const localVarPath = `/v1/proxy/pickups/{carrier_name}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {string} carrierName 
         * @param {ShipmentCancelRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel: async (carrierName: string, data: ShipmentCancelRequest, test?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('voidLabel', 'carrierName', carrierName)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('voidLabel', 'data', data)
            const localVarPath = `/v1/proxy/shipping/{carrier_name}/cancel`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxyApi - functional programming interface
 * @export
 */
export const ProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buyLabel(data: ShippingRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buyLabel(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {string} carrierName 
         * @param {PickupCancelRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPickup(carrierName: string, data: PickupCancelRequest, test?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPickup(carrierName, data, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRates(data: RateRequest, test?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRates(data, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulePickup(carrierName: string, data: PickupRequest, test?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulePickup(carrierName, data, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {string} carrierName 
         * @param {string} trackingNumber 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackShipment(carrierName: string, trackingNumber: string, test?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackShipment(carrierName, trackingNumber, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {string} carrierName 
         * @param {PickupUpdateRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePickup(carrierName: string, data: PickupUpdateRequest, test?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePickup(carrierName, data, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {string} carrierName 
         * @param {ShipmentCancelRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async voidLabel(carrierName: string, data: ShipmentCancelRequest, test?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.voidLabel(carrierName, data, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProxyApi - factory interface
 * @export
 */
export const ProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProxyApiFp(configuration)
    return {
        /**
         * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
         * @summary Buy a shipment label
         * @param {ShippingRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buyLabel(data: ShippingRequest, options?: any): AxiosPromise<Shipment> {
            return localVarFp.buyLabel(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a pickup previously scheduled
         * @summary Cancel a pickup
         * @param {string} carrierName 
         * @param {PickupCancelRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPickup(carrierName: string, data: PickupCancelRequest, test?: boolean, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.cancelPickup(carrierName, data, test, options).then((request) => request(axios, basePath));
        },
        /**
         *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
         * @summary Fetch shipment rates
         * @param {RateRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRates(data: RateRequest, test?: boolean, options?: any): AxiosPromise<RateResponse> {
            return localVarFp.fetchRates(data, test, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedule one or many parcels pickup
         * @summary Schedule a pickup
         * @param {string} carrierName 
         * @param {PickupRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePickup(carrierName: string, data: PickupRequest, test?: boolean, options?: any): AxiosPromise<PickupResponse> {
            return localVarFp.schedulePickup(carrierName, data, test, options).then((request) => request(axios, basePath));
        },
        /**
         * You can track a shipment by specifying the carrier and the shipment tracking number.
         * @summary Track a shipment
         * @param {string} carrierName 
         * @param {string} trackingNumber 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackShipment(carrierName: string, trackingNumber: string, test?: boolean, options?: any): AxiosPromise<TrackingResponse> {
            return localVarFp.trackShipment(carrierName, trackingNumber, test, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a scheduled pickup
         * @summary Update a pickup
         * @param {string} carrierName 
         * @param {PickupUpdateRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePickup(carrierName: string, data: PickupUpdateRequest, test?: boolean, options?: any): AxiosPromise<PickupResponse> {
            return localVarFp.updatePickup(carrierName, data, test, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a shipment and the label previously created
         * @summary Void a shipment label
         * @param {string} carrierName 
         * @param {ShipmentCancelRequest} data 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidLabel(carrierName: string, data: ShipmentCancelRequest, test?: boolean, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.voidLabel(carrierName, data, test, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProxyApi - object-oriented interface
 * @export
 * @class ProxyApi
 * @extends {BaseAPI}
 */
export class ProxyApi extends BaseAPI {
    /**
     * Once the shipping rates are retrieved, provide the required info to submit the shipment by specifying your preferred rate.
     * @summary Buy a shipment label
     * @param {ShippingRequest} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public buyLabel(data: ShippingRequest, options?: any) {
        return ProxyApiFp(this.configuration).buyLabel(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a pickup previously scheduled
     * @summary Cancel a pickup
     * @param {string} carrierName 
     * @param {PickupCancelRequest} data 
     * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public cancelPickup(carrierName: string, data: PickupCancelRequest, test?: boolean, options?: any) {
        return ProxyApiFp(this.configuration).cancelPickup(carrierName, data, test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The Shipping process begins by fetching rates for your shipment. Use this service to fetch a shipping rates available. 
     * @summary Fetch shipment rates
     * @param {RateRequest} data 
     * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public fetchRates(data: RateRequest, test?: boolean, options?: any) {
        return ProxyApiFp(this.configuration).fetchRates(data, test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedule one or many parcels pickup
     * @summary Schedule a pickup
     * @param {string} carrierName 
     * @param {PickupRequest} data 
     * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public schedulePickup(carrierName: string, data: PickupRequest, test?: boolean, options?: any) {
        return ProxyApiFp(this.configuration).schedulePickup(carrierName, data, test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can track a shipment by specifying the carrier and the shipment tracking number.
     * @summary Track a shipment
     * @param {string} carrierName 
     * @param {string} trackingNumber 
     * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public trackShipment(carrierName: string, trackingNumber: string, test?: boolean, options?: any) {
        return ProxyApiFp(this.configuration).trackShipment(carrierName, trackingNumber, test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify a scheduled pickup
     * @summary Update a pickup
     * @param {string} carrierName 
     * @param {PickupUpdateRequest} data 
     * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public updatePickup(carrierName: string, data: PickupUpdateRequest, test?: boolean, options?: any) {
        return ProxyApiFp(this.configuration).updatePickup(carrierName, data, test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a shipment and the label previously created
     * @summary Void a shipment label
     * @param {string} carrierName 
     * @param {ShipmentCancelRequest} data 
     * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public voidLabel(carrierName: string, data: ShipmentCancelRequest, test?: boolean, options?: any) {
        return ProxyApiFp(this.configuration).voidLabel(carrierName, data, test, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShipmentsApi - axios parameter creator
 * @export
 */
export const ShipmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add the customs declaration for the shipment if non existent.
         * @summary Add a customs declaration
         * @param {string} id 
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustoms: async (id: string, data: CustomsData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addCustoms', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('addCustoms', 'data', data)
            const localVarPath = `/v1/shipments/{id}/customs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a parcel to an existing shipment for a multi-parcel shipment.
         * @summary Add a shipment parcel
         * @param {string} id 
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addParcel: async (id: string, data: ParcelData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addParcel', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('addParcel', 'data', data)
            const localVarPath = `/v1/shipments/{id}/parcels`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} data 
         * @param {boolean} [test] Create shipment in test or prod mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: ShipmentData, test?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {boolean} [testMode] 
         * @param {'created' | 'purchased' | 'cancelled' | 'shipped' | 'in-transit' | 'delivered'} [status] 
         * @param {string} [createdStart] 
         * @param {string} [createdEnd] 
         * @param {string} [carrierId] 
         * @param {string} [service] 
         * @param {string} [reference] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom'} [carrierName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (testMode?: boolean, status?: 'created' | 'purchased' | 'cancelled' | 'shipped' | 'in-transit' | 'delivered', createdStart?: string, createdEnd?: string, carrierId?: string, service?: string, reference?: string, limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/shipments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdStart !== undefined) {
                localVarQueryParameter['created_start'] = (createdStart as any instanceof Date) ?
                    (createdStart as any).toISOString().substr(0,10) :
                    createdStart;
            }

            if (createdEnd !== undefined) {
                localVarQueryParameter['created_end'] = (createdEnd as any instanceof Date) ?
                    (createdEnd as any).toISOString().substr(0,10) :
                    createdEnd;
            }

            if (carrierId !== undefined) {
                localVarQueryParameter['carrier_id'] = carrierId;
            }

            if (service !== undefined) {
                localVarQueryParameter['service'] = service;
            }

            if (reference !== undefined) {
                localVarQueryParameter['reference'] = reference;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase: async (id: string, data: ShipmentPurchaseData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('purchase', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('purchase', 'data', data)
            const localVarPath = `/v1/shipments/{id}/purchase`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates: async (id: string, data: ShipmentRateData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rates', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('rates', 'data', data)
            const localVarPath = `/v1/shipments/{id}/rates`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/shipments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add one or many options to your shipment.<br/> **eg:**<br/> - add shipment **insurance** - specify the preferred transaction **currency** - setup a **cash collected on delivery** option  ```json {     \"insurance\": 120,     \"currency\": \"USD\" } ```  And many more, check additional options available in the [reference](#operation/all_references).
         * @summary Add shipment options
         * @param {string} id 
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOptions: async (id: string, data: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setOptions', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('setOptions', 'data', data)
            const localVarPath = `/v1/shipments/{id}/options`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShipmentsApi - functional programming interface
 * @export
 */
export const ShipmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShipmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add the customs declaration for the shipment if non existent.
         * @summary Add a customs declaration
         * @param {string} id 
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCustoms(id: string, data: CustomsData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCustoms(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a parcel to an existing shipment for a multi-parcel shipment.
         * @summary Add a shipment parcel
         * @param {string} id 
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addParcel(id: string, data: ParcelData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addParcel(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} data 
         * @param {boolean} [test] Create shipment in test or prod mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: ShipmentData, test?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {boolean} [testMode] 
         * @param {'created' | 'purchased' | 'cancelled' | 'shipped' | 'in-transit' | 'delivered'} [status] 
         * @param {string} [createdStart] 
         * @param {string} [createdEnd] 
         * @param {string} [carrierId] 
         * @param {string} [service] 
         * @param {string} [reference] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom'} [carrierName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(testMode?: boolean, status?: 'created' | 'purchased' | 'cancelled' | 'shipped' | 'in-transit' | 'delivered', createdStart?: string, createdEnd?: string, carrierId?: string, service?: string, reference?: string, limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShipmentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(testMode, status, createdStart, createdEnd, carrierId, service, reference, limit, offset, carrierName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchase(id: string, data: ShipmentPurchaseData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchase(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rates(id: string, data: ShipmentRateData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rates(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add one or many options to your shipment.<br/> **eg:**<br/> - add shipment **insurance** - specify the preferred transaction **currency** - setup a **cash collected on delivery** option  ```json {     \"insurance\": 120,     \"currency\": \"USD\" } ```  And many more, check additional options available in the [reference](#operation/all_references).
         * @summary Add shipment options
         * @param {string} id 
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOptions(id: string, data: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Shipment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOptions(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShipmentsApi - factory interface
 * @export
 */
export const ShipmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShipmentsApiFp(configuration)
    return {
        /**
         * Add the customs declaration for the shipment if non existent.
         * @summary Add a customs declaration
         * @param {string} id 
         * @param {CustomsData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustoms(id: string, data: CustomsData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.addCustoms(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a parcel to an existing shipment for a multi-parcel shipment.
         * @summary Add a shipment parcel
         * @param {string} id 
         * @param {ParcelData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addParcel(id: string, data: ParcelData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.addParcel(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Void a shipment with the associated label.
         * @summary Cancel a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(id: string, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.cancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shipment instance.
         * @summary Create a shipment
         * @param {ShipmentData} data 
         * @param {boolean} [test] Create shipment in test or prod mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: ShipmentData, test?: boolean, options?: any): AxiosPromise<Shipment> {
            return localVarFp.create(data, test, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipments.
         * @summary List all shipments
         * @param {boolean} [testMode] 
         * @param {'created' | 'purchased' | 'cancelled' | 'shipped' | 'in-transit' | 'delivered'} [status] 
         * @param {string} [createdStart] 
         * @param {string} [createdEnd] 
         * @param {string} [carrierId] 
         * @param {string} [service] 
         * @param {string} [reference] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom'} [carrierName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(testMode?: boolean, status?: 'created' | 'purchased' | 'cancelled' | 'shipped' | 'in-transit' | 'delivered', createdStart?: string, createdEnd?: string, carrierId?: string, service?: string, reference?: string, limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom', options?: any): AxiosPromise<ShipmentList> {
            return localVarFp.list(testMode, status, createdStart, createdEnd, carrierId, service, reference, limit, offset, carrierName, options).then((request) => request(axios, basePath));
        },
        /**
         * Select your preferred rates to buy a shipment label.
         * @summary Buy a shipment label
         * @param {string} id 
         * @param {ShipmentPurchaseData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchase(id: string, data: ShipmentPurchaseData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.purchase(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh the list of the shipment rates
         * @summary Fetch new shipment rates
         * @param {string} id 
         * @param {ShipmentRateData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rates(id: string, data: ShipmentRateData, options?: any): AxiosPromise<Shipment> {
            return localVarFp.rates(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipment.
         * @summary Retrieve a shipment
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Shipment> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Add one or many options to your shipment.<br/> **eg:**<br/> - add shipment **insurance** - specify the preferred transaction **currency** - setup a **cash collected on delivery** option  ```json {     \"insurance\": 120,     \"currency\": \"USD\" } ```  And many more, check additional options available in the [reference](#operation/all_references).
         * @summary Add shipment options
         * @param {string} id 
         * @param {object} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOptions(id: string, data: object, options?: any): AxiosPromise<Shipment> {
            return localVarFp.setOptions(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShipmentsApi - object-oriented interface
 * @export
 * @class ShipmentsApi
 * @extends {BaseAPI}
 */
export class ShipmentsApi extends BaseAPI {
    /**
     * Add the customs declaration for the shipment if non existent.
     * @summary Add a customs declaration
     * @param {string} id 
     * @param {CustomsData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public addCustoms(id: string, data: CustomsData, options?: any) {
        return ShipmentsApiFp(this.configuration).addCustoms(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a parcel to an existing shipment for a multi-parcel shipment.
     * @summary Add a shipment parcel
     * @param {string} id 
     * @param {ParcelData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public addParcel(id: string, data: ParcelData, options?: any) {
        return ShipmentsApiFp(this.configuration).addParcel(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Void a shipment with the associated label.
     * @summary Cancel a shipment
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public cancel(id: string, options?: any) {
        return ShipmentsApiFp(this.configuration).cancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new shipment instance.
     * @summary Create a shipment
     * @param {ShipmentData} data 
     * @param {boolean} [test] Create shipment in test or prod mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public create(data: ShipmentData, test?: boolean, options?: any) {
        return ShipmentsApiFp(this.configuration).create(data, test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipments.
     * @summary List all shipments
     * @param {boolean} [testMode] 
     * @param {'created' | 'purchased' | 'cancelled' | 'shipped' | 'in-transit' | 'delivered'} [status] 
     * @param {string} [createdStart] 
     * @param {string} [createdEnd] 
     * @param {string} [carrierId] 
     * @param {string} [service] 
     * @param {string} [reference] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom'} [carrierName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public list(testMode?: boolean, status?: 'created' | 'purchased' | 'cancelled' | 'shipped' | 'in-transit' | 'delivered', createdStart?: string, createdEnd?: string, carrierId?: string, service?: string, reference?: string, limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom', options?: any) {
        return ShipmentsApiFp(this.configuration).list(testMode, status, createdStart, createdEnd, carrierId, service, reference, limit, offset, carrierName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Select your preferred rates to buy a shipment label.
     * @summary Buy a shipment label
     * @param {string} id 
     * @param {ShipmentPurchaseData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public purchase(id: string, data: ShipmentPurchaseData, options?: any) {
        return ShipmentsApiFp(this.configuration).purchase(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh the list of the shipment rates
     * @summary Fetch new shipment rates
     * @param {string} id 
     * @param {ShipmentRateData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public rates(id: string, data: ShipmentRateData, options?: any) {
        return ShipmentsApiFp(this.configuration).rates(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipment.
     * @summary Retrieve a shipment
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public retrieve(id: string, options?: any) {
        return ShipmentsApiFp(this.configuration).retrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add one or many options to your shipment.<br/> **eg:**<br/> - add shipment **insurance** - specify the preferred transaction **currency** - setup a **cash collected on delivery** option  ```json {     \"insurance\": 120,     \"currency\": \"USD\" } ```  And many more, check additional options available in the [reference](#operation/all_references).
     * @summary Add shipment options
     * @param {string} id 
     * @param {object} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipmentsApi
     */
    public setOptions(id: string, data: object, options?: any) {
        return ShipmentsApiFp(this.configuration).setOptions(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackersApi - axios parameter creator
 * @export
 */
export const TrackersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a shipment tracker
         * @param {string} carrierName 
         * @param {string} trackingNumber 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (carrierName: string, trackingNumber: string, test?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carrierName' is not null or undefined
            assertParamExists('create', 'carrierName', carrierName)
            // verify required parameter 'trackingNumber' is not null or undefined
            assertParamExists('create', 'trackingNumber', trackingNumber)
            const localVarPath = `/v1/trackers/{carrier_name}/{tracking_number}`
                .replace(`{${"carrier_name"}}`, encodeURIComponent(String(carrierName)))
                .replace(`{${"tracking_number"}}`, encodeURIComponent(String(trackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all shipment trackers
         * @param {boolean} [testMode] 
         * @param {'pending' | 'in-transit' | 'incident' | 'delivered'} [status] 
         * @param {string} [carrierId] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom'} [carrierName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (testMode?: boolean, status?: 'pending' | 'in-transit' | 'incident' | 'delivered', carrierId?: string, limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (carrierId !== undefined) {
                localVarQueryParameter['carrier_id'] = carrierId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (carrierName !== undefined) {
                localVarQueryParameter['carrier_name'] = carrierName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Discard a shipment tracker.
         * @summary Discard a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (idOrTrackingNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('remove', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a shipment tracker
         * @summary Retrieves a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieves: async (idOrTrackingNumber: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrTrackingNumber' is not null or undefined
            assertParamExists('retrieves', 'idOrTrackingNumber', idOrTrackingNumber)
            const localVarPath = `/v1/trackers/{id_or_tracking_number}`
                .replace(`{${"id_or_tracking_number"}}`, encodeURIComponent(String(idOrTrackingNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackersApi - functional programming interface
 * @export
 */
export const TrackersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackersApiAxiosParamCreator(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a shipment tracker
         * @param {string} carrierName 
         * @param {string} trackingNumber 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(carrierName: string, trackingNumber: string, test?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(carrierName, trackingNumber, test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all shipment trackers
         * @param {boolean} [testMode] 
         * @param {'pending' | 'in-transit' | 'incident' | 'delivered'} [status] 
         * @param {string} [carrierId] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom'} [carrierName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(testMode?: boolean, status?: 'pending' | 'in-transit' | 'incident' | 'delivered', carrierId?: string, limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(testMode, status, carrierId, limit, offset, carrierName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Discard a shipment tracker.
         * @summary Discard a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(idOrTrackingNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(idOrTrackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a shipment tracker
         * @summary Retrieves a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieves(idOrTrackingNumber: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackingStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieves(idOrTrackingNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackersApi - factory interface
 * @export
 */
export const TrackersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackersApiFp(configuration)
    return {
        /**
         * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
         * @summary Create a shipment tracker
         * @param {string} carrierName 
         * @param {string} trackingNumber 
         * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(carrierName: string, trackingNumber: string, test?: boolean, options?: any): AxiosPromise<TrackingStatus> {
            return localVarFp.create(carrierName, trackingNumber, test, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all shipment trackers.
         * @summary List all shipment trackers
         * @param {boolean} [testMode] 
         * @param {'pending' | 'in-transit' | 'incident' | 'delivered'} [status] 
         * @param {string} [carrierId] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom'} [carrierName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(testMode?: boolean, status?: 'pending' | 'in-transit' | 'incident' | 'delivered', carrierId?: string, limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom', options?: any): AxiosPromise<TrackerList> {
            return localVarFp.list(testMode, status, carrierId, limit, offset, carrierName, options).then((request) => request(axios, basePath));
        },
        /**
         * Discard a shipment tracker.
         * @summary Discard a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(idOrTrackingNumber: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.remove(idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a shipment tracker
         * @summary Retrieves a shipment tracker
         * @param {string} idOrTrackingNumber 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieves(idOrTrackingNumber: string, options?: any): AxiosPromise<TrackingStatus> {
            return localVarFp.retrieves(idOrTrackingNumber, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrackersApi - object-oriented interface
 * @export
 * @class TrackersApi
 * @extends {BaseAPI}
 */
export class TrackersApi extends BaseAPI {
    /**
     * This API creates or retrieves (if existent) a tracking status object containing the details and events of a shipping in progress.
     * @summary Create a shipment tracker
     * @param {string} carrierName 
     * @param {string} trackingNumber 
     * @param {boolean} [test] The test flag indicates whether to use a carrier configured for test.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public create(carrierName: string, trackingNumber: string, test?: boolean, options?: any) {
        return TrackersApiFp(this.configuration).create(carrierName, trackingNumber, test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all shipment trackers.
     * @summary List all shipment trackers
     * @param {boolean} [testMode] 
     * @param {'pending' | 'in-transit' | 'incident' | 'delivered'} [status] 
     * @param {string} [carrierId] 
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom'} [carrierName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public list(testMode?: boolean, status?: 'pending' | 'in-transit' | 'incident' | 'delivered', carrierId?: string, limit?: number, offset?: number, carrierName?: 'aramex' | 'australiapost' | 'canadapost' | 'canpar' | 'dhl_express' | 'dhl_universal' | 'dicom' | 'fedex' | 'purolator' | 'royalmail' | 'sendle' | 'sf_express' | 'tnt' | 'ups' | 'usps' | 'usps_international' | 'yanwen' | 'yunexpress' | 'eshipper' | 'freightcom', options?: any) {
        return TrackersApiFp(this.configuration).list(testMode, status, carrierId, limit, offset, carrierName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Discard a shipment tracker.
     * @summary Discard a shipment tracker
     * @param {string} idOrTrackingNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public remove(idOrTrackingNumber: string, options?: any) {
        return TrackersApiFp(this.configuration).remove(idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a shipment tracker
     * @summary Retrieves a shipment tracker
     * @param {string} idOrTrackingNumber 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackersApi
     */
    public retrieves(idOrTrackingNumber: string, options?: any) {
        return TrackersApiFp(this.configuration).retrieves(idOrTrackingNumber, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (data: WebhookData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('create', 'data', data)
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {boolean} [testMode] This flag filter out webhooks created in test or live mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (limit?: number, offset?: number, testMode?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('remove', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieve', 'id', id)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (id: string, data: WebhookTestRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('test', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('test', 'data', data)
            const localVarPath = `/v1/webhooks/{id}/test`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, data: WebhookData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('update', 'data', data)
            const localVarPath = `/v1/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(data: WebhookData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {boolean} [testMode] This flag filter out webhooks created in test or live mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(limit?: number, offset?: number, testMode?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(limit, offset, testMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remove(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(id: string, data: WebhookTestRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, data: WebhookData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create a new webhook.
         * @summary Create a webhook
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(data: WebhookData, options?: any): AxiosPromise<Webhook> {
            return localVarFp.create(data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all webhooks.
         * @summary List all webhooks
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {boolean} [testMode] This flag filter out webhooks created in test or live mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(limit?: number, offset?: number, testMode?: boolean, options?: any): AxiosPromise<WebhookList> {
            return localVarFp.list(limit, offset, testMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a webhook.
         * @summary Remove a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remove(id: string, options?: any): AxiosPromise<Operation> {
            return localVarFp.remove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a webhook.
         * @summary Retrieve a webhook
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(id: string, options?: any): AxiosPromise<Webhook> {
            return localVarFp.retrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * test a webhook.
         * @summary Test a webhook
         * @param {string} id 
         * @param {WebhookTestRequest} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(id: string, data: WebhookTestRequest, options?: any): AxiosPromise<Operation> {
            return localVarFp.test(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * update a webhook.
         * @summary Update a webhook
         * @param {string} id 
         * @param {WebhookData} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, data: WebhookData, options?: any): AxiosPromise<Webhook> {
            return localVarFp.update(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook.
     * @summary Create a webhook
     * @param {WebhookData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public create(data: WebhookData, options?: any) {
        return WebhooksApiFp(this.configuration).create(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all webhooks.
     * @summary List all webhooks
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {boolean} [testMode] This flag filter out webhooks created in test or live mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public list(limit?: number, offset?: number, testMode?: boolean, options?: any) {
        return WebhooksApiFp(this.configuration).list(limit, offset, testMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a webhook.
     * @summary Remove a webhook
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public remove(id: string, options?: any) {
        return WebhooksApiFp(this.configuration).remove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a webhook.
     * @summary Retrieve a webhook
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public retrieve(id: string, options?: any) {
        return WebhooksApiFp(this.configuration).retrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * test a webhook.
     * @summary Test a webhook
     * @param {string} id 
     * @param {WebhookTestRequest} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public test(id: string, data: WebhookTestRequest, options?: any) {
        return WebhooksApiFp(this.configuration).test(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update a webhook.
     * @summary Update a webhook
     * @param {string} id 
     * @param {WebhookData} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public update(id: string, data: WebhookData, options?: any) {
        return WebhooksApiFp(this.configuration).update(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}


